/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_host {
    _unused: [u8; 0],
}
#[doc = " The VSLHost object manages a connection point at the user-defined path and\n allows frames to be registered for client use."]
pub type VSLHost = vsl_host;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_client {
    _unused: [u8; 0],
}
#[doc = " The VSLClient object manages a single connection to a VSLHost."]
pub type VSLClient = vsl_client;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_frame {
    _unused: [u8; 0],
}
#[doc = " The VSLFrame object represents a single video frame from either the host\n or client perspective.  Certain API are only available to the host or client."]
pub type VSLFrame = vsl_frame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_encoder {
    _unused: [u8; 0],
}
#[doc = " The VSLEncoder object represents encoder instance.\n"]
pub type VSLEncoder = vsl_encoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_decoder {
    _unused: [u8; 0],
}
#[doc = " The VSLEncoder object represents encoder instance.\n"]
pub type VSLDecoder = vsl_decoder;
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_rect {
    #[doc = " The left-most pixel offset for the rectangle."]
    pub x: ::std::os::raw::c_int,
    #[doc = " The top-most pixel offset for the rectangle."]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width in pixels of the rectangle.  The end position is x+width."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height in pixels of the rectangle.  The end position is y+height."]
    pub height: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsl_rect"][::std::mem::size_of::<vsl_rect>() - 16usize];
    ["Alignment of vsl_rect"][::std::mem::align_of::<vsl_rect>() - 4usize];
    ["Offset of field: vsl_rect::x"][::std::mem::offset_of!(vsl_rect, x) - 0usize];
    ["Offset of field: vsl_rect::y"][::std::mem::offset_of!(vsl_rect, y) - 4usize];
    ["Offset of field: vsl_rect::width"][::std::mem::offset_of!(vsl_rect, width) - 8usize];
    ["Offset of field: vsl_rect::height"][::std::mem::offset_of!(vsl_rect, height) - 12usize];
};
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
pub type VSLRect = vsl_rect;
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_AUTO: vsl_encode_profile = 0;
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_5000_KBPS: vsl_encode_profile = 1;
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_25000_KBPS: vsl_encode_profile = 2;
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_50000_KBPS: vsl_encode_profile = 3;
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_100000_KBPS: vsl_encode_profile = 4;
pub type vsl_encode_profile = ::std::os::raw::c_uint;
pub use self::vsl_encode_profile as VSLEncoderProfile;
#[doc = " Function pointer definition which will be called as part of\n @ref vsl_frame_unregister.  This is typically used to free resources\n associated with the frame on either client or host side."]
pub type vsl_frame_cleanup = ::std::option::Option<unsafe extern "C" fn(frame: *mut VSLFrame)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_camera_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_camera {
    _unused: [u8; 0],
}
pub const VSLDecoderRetCode_VSL_DEC_SUCCESS: VSLDecoderRetCode = 0;
pub const VSLDecoderRetCode_VSL_DEC_ERR: VSLDecoderRetCode = 1;
pub const VSLDecoderRetCode_VSL_DEC_INIT_INFO: VSLDecoderRetCode = 2;
pub const VSLDecoderRetCode_VSL_DEC_FRAME_DEC: VSLDecoderRetCode = 4;
pub type VSLDecoderRetCode = ::std::os::raw::c_uint;
pub struct VideoStreamLibrary {
    __library: ::libloading::Library,
    pub vsl_version:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub vsl_timestamp: Result<unsafe extern "C" fn() -> i64, ::libloading::Error>,
    pub vsl_host_init: Result<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char) -> *mut VSLHost,
        ::libloading::Error,
    >,
    pub vsl_host_release: Result<unsafe extern "C" fn(host: *mut VSLHost), ::libloading::Error>,
    pub vsl_host_path: Result<
        unsafe extern "C" fn(host: *const VSLHost) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_host_poll: Result<
        unsafe extern "C" fn(host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_service: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            sock: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_process: Result<
        unsafe extern "C" fn(host: *mut VSLHost) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_sockets: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            n_sockets: usize,
            sockets: *mut ::std::os::raw::c_int,
            max_sockets: *mut usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_post: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            frame: *mut VSLFrame,
            expires: i64,
            duration: i64,
            pts: i64,
            dts: i64,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_drop: Result<
        unsafe extern "C" fn(host: *mut VSLHost, frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_client_init: Result<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            userptr: *mut ::std::os::raw::c_void,
            reconnect: bool,
        ) -> *mut VSLClient,
        ::libloading::Error,
    >,
    pub vsl_client_release:
        Result<unsafe extern "C" fn(client: *mut VSLClient), ::libloading::Error>,
    pub vsl_client_disconnect:
        Result<unsafe extern "C" fn(client: *mut VSLClient), ::libloading::Error>,
    pub vsl_client_userptr: Result<
        unsafe extern "C" fn(client: *mut VSLClient) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_client_path: Result<
        unsafe extern "C" fn(client: *const VSLClient) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_client_set_timeout:
        Result<unsafe extern "C" fn(client: *mut VSLClient, timeout: f32), ::libloading::Error>,
    pub vsl_frame_register: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            serial: i64,
            handle: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            fourcc: u32,
            size: usize,
            offset: usize,
            expires: i64,
            duration: i64,
            pts: i64,
            dts: i64,
            cleanup: vsl_frame_cleanup,
            userptr: *mut ::std::os::raw::c_void,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_init: Result<
        unsafe extern "C" fn(
            width: u32,
            height: u32,
            stride: u32,
            fourcc: u32,
            userptr: *mut ::std::os::raw::c_void,
            cleanup: vsl_frame_cleanup,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_alloc: Result<
        unsafe extern "C" fn(
            frame: *mut VSLFrame,
            path: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_unalloc: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_attach: Result<
        unsafe extern "C" fn(
            frame: *mut VSLFrame,
            fd: ::std::os::raw::c_int,
            size: usize,
            offset: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_path: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_frame_unregister:
        Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_copy: Result<
        unsafe extern "C" fn(
            target: *mut VSLFrame,
            source: *mut VSLFrame,
            crop: *const VSLRect,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_userptr: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_frame_set_userptr: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame, userptr: *mut ::std::os::raw::c_void),
        ::libloading::Error,
    >,
    pub vsl_frame_wait: Result<
        unsafe extern "C" fn(client: *mut VSLClient, until: i64) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_release: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_trylock: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_unlock: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_serial:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_timestamp:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_duration:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_pts:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_dts:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_expires:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_fourcc:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> u32, ::libloading::Error>,
    pub vsl_frame_width: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_height: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_stride: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_size: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_handle: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_paddr:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> isize, ::libloading::Error>,
    pub vsl_frame_mmap: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame, size: *mut usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_frame_munmap: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_sync: Result<
        unsafe extern "C" fn(
            frame: *const VSLFrame,
            enable: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_fourcc_from_string: Result<
        unsafe extern "C" fn(fourcc: *const ::std::os::raw::c_char) -> u32,
        ::libloading::Error,
    >,
    pub vsl_encoder_create: Result<
        unsafe extern "C" fn(
            profile: VSLEncoderProfile,
            outputFourcc: u32,
            fps: ::std::os::raw::c_int,
        ) -> *mut VSLEncoder,
        ::libloading::Error,
    >,
    pub vsl_encoder_release:
        Result<unsafe extern "C" fn(encoder: *mut VSLEncoder), ::libloading::Error>,
    pub vsl_encode_frame: Result<
        unsafe extern "C" fn(
            encoder: *mut VSLEncoder,
            source: *mut VSLFrame,
            destination: *mut VSLFrame,
            cropRegion: *const VSLRect,
            keyframe: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_encoder_new_output_frame: Result<
        unsafe extern "C" fn(
            encoder: *const VSLEncoder,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            duration: i64,
            pts: i64,
            dts: i64,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_camera_open_device: Result<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut vsl_camera,
        ::libloading::Error,
    >,
    pub vsl_camera_init_device: Result<
        unsafe extern "C" fn(
            ctx: *mut vsl_camera,
            width: *mut ::std::os::raw::c_int,
            height: *mut ::std::os::raw::c_int,
            buf_count: *mut ::std::os::raw::c_int,
            fourcc: *mut u32,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_mirror: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera, mirror: bool) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_mirror_v: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera, mirror: bool) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_start_capturing: Result<
        unsafe extern "C" fn(ctx: *mut vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_get_data: Result<
        unsafe extern "C" fn(ctx: *mut vsl_camera) -> *mut vsl_camera_buffer,
        ::libloading::Error,
    >,
    pub vsl_camera_release_buffer: Result<
        unsafe extern "C" fn(
            ctx: *mut vsl_camera,
            buffer: *const vsl_camera_buffer,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_stop_capturing: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_uninit_device:
        Result<unsafe extern "C" fn(ctx: *mut vsl_camera), ::libloading::Error>,
    pub vsl_camera_close_device:
        Result<unsafe extern "C" fn(ctx: *mut vsl_camera), ::libloading::Error>,
    pub vsl_camera_is_dmabuf_supported: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_get_queued_buf_count: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_mmap: Result<
        unsafe extern "C" fn(buffer: *mut vsl_camera_buffer) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_dma_fd: Result<
        unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_phys_addr:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u64, ::libloading::Error>,
    pub vsl_camera_buffer_length:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u32, ::libloading::Error>,
    pub vsl_camera_buffer_fourcc:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u32, ::libloading::Error>,
    pub vsl_camera_buffer_timestamp: Result<
        unsafe extern "C" fn(
            buffer: *const vsl_camera_buffer,
            seconds: *mut i64,
            nanoseconds: *mut i64,
        ),
        ::libloading::Error,
    >,
    pub vsl_camera_enum_fmts: Result<
        unsafe extern "C" fn(
            ctx: *const vsl_camera,
            codes: *mut u32,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_enum_mplane_fmts: Result<
        unsafe extern "C" fn(
            ctx: *const vsl_camera,
            codes: *mut u32,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_create: Result<
        unsafe extern "C" fn(outputFourcc: u32, fps: ::std::os::raw::c_int) -> *mut VSLDecoder,
        ::libloading::Error,
    >,
    pub vsl_decode_frame: Result<
        unsafe extern "C" fn(
            decoder: *mut VSLDecoder,
            data: *const ::std::os::raw::c_void,
            data_length: ::std::os::raw::c_uint,
            bytes_used: *mut usize,
            output_frame: *mut *mut VSLFrame,
        ) -> VSLDecoderRetCode,
        ::libloading::Error,
    >,
    pub vsl_decoder_width: Result<
        unsafe extern "C" fn(decoder: *const VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_height: Result<
        unsafe extern "C" fn(decoder: *const VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_crop:
        Result<unsafe extern "C" fn(decoder: *const VSLDecoder) -> VSLRect, ::libloading::Error>,
    pub vsl_decoder_release: Result<
        unsafe extern "C" fn(decoder: *mut VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
}
impl VideoStreamLibrary {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let vsl_version = __library.get(b"vsl_version\0").map(|sym| *sym);
        let vsl_timestamp = __library.get(b"vsl_timestamp\0").map(|sym| *sym);
        let vsl_host_init = __library.get(b"vsl_host_init\0").map(|sym| *sym);
        let vsl_host_release = __library.get(b"vsl_host_release\0").map(|sym| *sym);
        let vsl_host_path = __library.get(b"vsl_host_path\0").map(|sym| *sym);
        let vsl_host_poll = __library.get(b"vsl_host_poll\0").map(|sym| *sym);
        let vsl_host_service = __library.get(b"vsl_host_service\0").map(|sym| *sym);
        let vsl_host_process = __library.get(b"vsl_host_process\0").map(|sym| *sym);
        let vsl_host_sockets = __library.get(b"vsl_host_sockets\0").map(|sym| *sym);
        let vsl_host_post = __library.get(b"vsl_host_post\0").map(|sym| *sym);
        let vsl_host_drop = __library.get(b"vsl_host_drop\0").map(|sym| *sym);
        let vsl_client_init = __library.get(b"vsl_client_init\0").map(|sym| *sym);
        let vsl_client_release = __library.get(b"vsl_client_release\0").map(|sym| *sym);
        let vsl_client_disconnect = __library.get(b"vsl_client_disconnect\0").map(|sym| *sym);
        let vsl_client_userptr = __library.get(b"vsl_client_userptr\0").map(|sym| *sym);
        let vsl_client_path = __library.get(b"vsl_client_path\0").map(|sym| *sym);
        let vsl_client_set_timeout = __library.get(b"vsl_client_set_timeout\0").map(|sym| *sym);
        let vsl_frame_register = __library.get(b"vsl_frame_register\0").map(|sym| *sym);
        let vsl_frame_init = __library.get(b"vsl_frame_init\0").map(|sym| *sym);
        let vsl_frame_alloc = __library.get(b"vsl_frame_alloc\0").map(|sym| *sym);
        let vsl_frame_unalloc = __library.get(b"vsl_frame_unalloc\0").map(|sym| *sym);
        let vsl_frame_attach = __library.get(b"vsl_frame_attach\0").map(|sym| *sym);
        let vsl_frame_path = __library.get(b"vsl_frame_path\0").map(|sym| *sym);
        let vsl_frame_unregister = __library.get(b"vsl_frame_unregister\0").map(|sym| *sym);
        let vsl_frame_copy = __library.get(b"vsl_frame_copy\0").map(|sym| *sym);
        let vsl_frame_userptr = __library.get(b"vsl_frame_userptr\0").map(|sym| *sym);
        let vsl_frame_set_userptr = __library.get(b"vsl_frame_set_userptr\0").map(|sym| *sym);
        let vsl_frame_wait = __library.get(b"vsl_frame_wait\0").map(|sym| *sym);
        let vsl_frame_release = __library.get(b"vsl_frame_release\0").map(|sym| *sym);
        let vsl_frame_trylock = __library.get(b"vsl_frame_trylock\0").map(|sym| *sym);
        let vsl_frame_unlock = __library.get(b"vsl_frame_unlock\0").map(|sym| *sym);
        let vsl_frame_serial = __library.get(b"vsl_frame_serial\0").map(|sym| *sym);
        let vsl_frame_timestamp = __library.get(b"vsl_frame_timestamp\0").map(|sym| *sym);
        let vsl_frame_duration = __library.get(b"vsl_frame_duration\0").map(|sym| *sym);
        let vsl_frame_pts = __library.get(b"vsl_frame_pts\0").map(|sym| *sym);
        let vsl_frame_dts = __library.get(b"vsl_frame_dts\0").map(|sym| *sym);
        let vsl_frame_expires = __library.get(b"vsl_frame_expires\0").map(|sym| *sym);
        let vsl_frame_fourcc = __library.get(b"vsl_frame_fourcc\0").map(|sym| *sym);
        let vsl_frame_width = __library.get(b"vsl_frame_width\0").map(|sym| *sym);
        let vsl_frame_height = __library.get(b"vsl_frame_height\0").map(|sym| *sym);
        let vsl_frame_stride = __library.get(b"vsl_frame_stride\0").map(|sym| *sym);
        let vsl_frame_size = __library.get(b"vsl_frame_size\0").map(|sym| *sym);
        let vsl_frame_handle = __library.get(b"vsl_frame_handle\0").map(|sym| *sym);
        let vsl_frame_paddr = __library.get(b"vsl_frame_paddr\0").map(|sym| *sym);
        let vsl_frame_mmap = __library.get(b"vsl_frame_mmap\0").map(|sym| *sym);
        let vsl_frame_munmap = __library.get(b"vsl_frame_munmap\0").map(|sym| *sym);
        let vsl_frame_sync = __library.get(b"vsl_frame_sync\0").map(|sym| *sym);
        let vsl_fourcc_from_string = __library.get(b"vsl_fourcc_from_string\0").map(|sym| *sym);
        let vsl_encoder_create = __library.get(b"vsl_encoder_create\0").map(|sym| *sym);
        let vsl_encoder_release = __library.get(b"vsl_encoder_release\0").map(|sym| *sym);
        let vsl_encode_frame = __library.get(b"vsl_encode_frame\0").map(|sym| *sym);
        let vsl_encoder_new_output_frame = __library
            .get(b"vsl_encoder_new_output_frame\0")
            .map(|sym| *sym);
        let vsl_camera_open_device = __library.get(b"vsl_camera_open_device\0").map(|sym| *sym);
        let vsl_camera_init_device = __library.get(b"vsl_camera_init_device\0").map(|sym| *sym);
        let vsl_camera_mirror = __library.get(b"vsl_camera_mirror\0").map(|sym| *sym);
        let vsl_camera_mirror_v = __library.get(b"vsl_camera_mirror_v\0").map(|sym| *sym);
        let vsl_camera_start_capturing = __library
            .get(b"vsl_camera_start_capturing\0")
            .map(|sym| *sym);
        let vsl_camera_get_data = __library.get(b"vsl_camera_get_data\0").map(|sym| *sym);
        let vsl_camera_release_buffer = __library
            .get(b"vsl_camera_release_buffer\0")
            .map(|sym| *sym);
        let vsl_camera_stop_capturing = __library
            .get(b"vsl_camera_stop_capturing\0")
            .map(|sym| *sym);
        let vsl_camera_uninit_device = __library.get(b"vsl_camera_uninit_device\0").map(|sym| *sym);
        let vsl_camera_close_device = __library.get(b"vsl_camera_close_device\0").map(|sym| *sym);
        let vsl_camera_is_dmabuf_supported = __library
            .get(b"vsl_camera_is_dmabuf_supported\0")
            .map(|sym| *sym);
        let vsl_camera_get_queued_buf_count = __library
            .get(b"vsl_camera_get_queued_buf_count\0")
            .map(|sym| *sym);
        let vsl_camera_buffer_mmap = __library.get(b"vsl_camera_buffer_mmap\0").map(|sym| *sym);
        let vsl_camera_buffer_dma_fd = __library.get(b"vsl_camera_buffer_dma_fd\0").map(|sym| *sym);
        let vsl_camera_buffer_phys_addr = __library
            .get(b"vsl_camera_buffer_phys_addr\0")
            .map(|sym| *sym);
        let vsl_camera_buffer_length = __library.get(b"vsl_camera_buffer_length\0").map(|sym| *sym);
        let vsl_camera_buffer_fourcc = __library.get(b"vsl_camera_buffer_fourcc\0").map(|sym| *sym);
        let vsl_camera_buffer_timestamp = __library
            .get(b"vsl_camera_buffer_timestamp\0")
            .map(|sym| *sym);
        let vsl_camera_enum_fmts = __library.get(b"vsl_camera_enum_fmts\0").map(|sym| *sym);
        let vsl_camera_enum_mplane_fmts = __library
            .get(b"vsl_camera_enum_mplane_fmts\0")
            .map(|sym| *sym);
        let vsl_decoder_create = __library.get(b"vsl_decoder_create\0").map(|sym| *sym);
        let vsl_decode_frame = __library.get(b"vsl_decode_frame\0").map(|sym| *sym);
        let vsl_decoder_width = __library.get(b"vsl_decoder_width\0").map(|sym| *sym);
        let vsl_decoder_height = __library.get(b"vsl_decoder_height\0").map(|sym| *sym);
        let vsl_decoder_crop = __library.get(b"vsl_decoder_crop\0").map(|sym| *sym);
        let vsl_decoder_release = __library.get(b"vsl_decoder_release\0").map(|sym| *sym);
        Ok(VideoStreamLibrary {
            __library,
            vsl_version,
            vsl_timestamp,
            vsl_host_init,
            vsl_host_release,
            vsl_host_path,
            vsl_host_poll,
            vsl_host_service,
            vsl_host_process,
            vsl_host_sockets,
            vsl_host_post,
            vsl_host_drop,
            vsl_client_init,
            vsl_client_release,
            vsl_client_disconnect,
            vsl_client_userptr,
            vsl_client_path,
            vsl_client_set_timeout,
            vsl_frame_register,
            vsl_frame_init,
            vsl_frame_alloc,
            vsl_frame_unalloc,
            vsl_frame_attach,
            vsl_frame_path,
            vsl_frame_unregister,
            vsl_frame_copy,
            vsl_frame_userptr,
            vsl_frame_set_userptr,
            vsl_frame_wait,
            vsl_frame_release,
            vsl_frame_trylock,
            vsl_frame_unlock,
            vsl_frame_serial,
            vsl_frame_timestamp,
            vsl_frame_duration,
            vsl_frame_pts,
            vsl_frame_dts,
            vsl_frame_expires,
            vsl_frame_fourcc,
            vsl_frame_width,
            vsl_frame_height,
            vsl_frame_stride,
            vsl_frame_size,
            vsl_frame_handle,
            vsl_frame_paddr,
            vsl_frame_mmap,
            vsl_frame_munmap,
            vsl_frame_sync,
            vsl_fourcc_from_string,
            vsl_encoder_create,
            vsl_encoder_release,
            vsl_encode_frame,
            vsl_encoder_new_output_frame,
            vsl_camera_open_device,
            vsl_camera_init_device,
            vsl_camera_mirror,
            vsl_camera_mirror_v,
            vsl_camera_start_capturing,
            vsl_camera_get_data,
            vsl_camera_release_buffer,
            vsl_camera_stop_capturing,
            vsl_camera_uninit_device,
            vsl_camera_close_device,
            vsl_camera_is_dmabuf_supported,
            vsl_camera_get_queued_buf_count,
            vsl_camera_buffer_mmap,
            vsl_camera_buffer_dma_fd,
            vsl_camera_buffer_phys_addr,
            vsl_camera_buffer_length,
            vsl_camera_buffer_fourcc,
            vsl_camera_buffer_timestamp,
            vsl_camera_enum_fmts,
            vsl_camera_enum_mplane_fmts,
            vsl_decoder_create,
            vsl_decode_frame,
            vsl_decoder_width,
            vsl_decoder_height,
            vsl_decoder_crop,
            vsl_decoder_release,
        })
    }
    #[doc = " Returns the VideoStream Library version."]
    pub unsafe fn vsl_version(&self) -> *const ::std::os::raw::c_char {
        (self
            .vsl_version
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn vsl_timestamp(&self) -> i64 {
        (self
            .vsl_timestamp
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Creates a host on the requested path.  If the path is unavailable because\n of permissions or already exists then NULL is returned and errno is set.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_init(&self, path: *const ::std::os::raw::c_char) -> *mut VSLHost {
        (self
            .vsl_host_init
            .as_ref()
            .expect("Expected function, got error."))(path)
    }
    #[doc = " Releases the host, disconnecting all clients and releasing any allocated\n memory.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_release(&self, host: *mut VSLHost) {
        (self
            .vsl_host_release
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Returns the bound path of the host.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_path(&self, host: *const VSLHost) -> *const ::std::os::raw::c_char {
        (self
            .vsl_host_path
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Polls the list of available connections in our pool.  If @param wait is >0\n then poll will timeout after @param wait milliseconds.  Note frames are only\n expired by the @ref vsl_host_process function so the @param wait parameter\n should be some value no greater than the desired expiration time.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_poll(&self, host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int {
        (self
            .vsl_host_poll
            .as_ref()
            .expect("Expected function, got error."))(host, wait)
    }
    #[doc = " Services a single client socket.  Note this does not accept new sockets for\n that you must call @ref vsl_host_process().  The main advantage over calling\n this function is to see if individual client servicing resulted in an error.\n\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_service(
        &self,
        host: *mut VSLHost,
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_service
            .as_ref()
            .expect("Expected function, got error."))(host, sock)
    }
    #[doc = " Process the host tasks by first expiring old frames and then servicing the\n first available connection in our pool.  This function should be called in a\n loop, generally blocked by @ref vsl_host_poll.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_process(&self, host: *mut VSLHost) -> ::std::os::raw::c_int {
        (self
            .vsl_host_process
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Request a copy of the sockets managed by the host.  There will always be at\n least one socket which is the connection socket which accepts new\n connections.  Up to n_sockets socket descriptors will be copied into the\n sockets buffer, if n_sockets is fewer than the number of available sockets\n errno will be set to ENOBUFS. The n_socket parameter, if provided, will be\n populated with a value of n_clients+1 which can be used to query required\n space for the sockets buffer.  It is suggested to provide a buffer which is\n larger than max_sockets to avoid race conditions where the number of sockets\n changes between calls to this function.\n\n Note that the array of sockets should be refreshed often as once the function\n returns they may be stale.  The API is implemented in such as way as to allow\n thread-safe operations where one thread may-be using the vsl sockets to send\n messages while another is polling for a read.\n\n @memberof VSLHost"]
    pub unsafe fn vsl_host_sockets(
        &self,
        host: *mut VSLHost,
        n_sockets: usize,
        sockets: *mut ::std::os::raw::c_int,
        max_sockets: *mut usize,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_sockets
            .as_ref()
            .expect("Expected function, got error."))(host, n_sockets, sockets, max_sockets)
    }
    #[doc = " Registers the frame with the host and publishes it to subscribers.\n\n @note A frame posted to this function transfers ownership to the host and\n should not have @ref vsl_frame_release called on it.  This will be managed\n by the host on frame expiry."]
    pub unsafe fn vsl_host_post(
        &self,
        host: *mut VSLHost,
        frame: *mut VSLFrame,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_post
            .as_ref()
            .expect("Expected function, got error."))(
            host, frame, expires, duration, pts, dts
        )
    }
    #[doc = " Drops the frame from the host.  This is meant to be called from the frame\n but can also be used to remove the host association of the frame and return\n ownership to the caller.\n\n @since 1.3\n @memberof VSLHost"]
    pub unsafe fn vsl_host_drop(
        &self,
        host: *mut VSLHost,
        frame: *mut VSLFrame,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_drop
            .as_ref()
            .expect("Expected function, got error."))(host, frame)
    }
    #[doc = " Creates a client and connects to the host at the provided path.  If the\n connection cannot be made NULL is returned and errno is set.\n\n @memberof VSLClient"]
    pub unsafe fn vsl_client_init(
        &self,
        path: *const ::std::os::raw::c_char,
        userptr: *mut ::std::os::raw::c_void,
        reconnect: bool,
    ) -> *mut VSLClient {
        (self
            .vsl_client_init
            .as_ref()
            .expect("Expected function, got error."))(path, userptr, reconnect)
    }
    #[doc = " Releases the client, disconnecting from the host and releasing allocated\n memory.\n\n @memberof VSLClient"]
    pub unsafe fn vsl_client_release(&self, client: *mut VSLClient) {
        (self
            .vsl_client_release
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Disconnects from the VSLHost and stops all reconnection attempts.  This\n should be called as part of closing down a VSL client session.  It is\n thread-safe unlike vsl_client_release which disposes of the client object.\n\n @memberof VSLClient\n @since 1.1"]
    pub unsafe fn vsl_client_disconnect(&self, client: *mut VSLClient) {
        (self
            .vsl_client_disconnect
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Returns the optional userptr associated with this client connection.\n\n @memberof VSLClient"]
    pub unsafe fn vsl_client_userptr(&self, client: *mut VSLClient) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_client_userptr
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Returns the path on which the client has connected to the host.\n\n @memberof VSLClient"]
    pub unsafe fn vsl_client_path(
        &self,
        client: *const VSLClient,
    ) -> *const ::std::os::raw::c_char {
        (self
            .vsl_client_path
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Sets the socket timeout for this client.\n\n @memberof VSLClient"]
    pub unsafe fn vsl_client_set_timeout(&self, client: *mut VSLClient, timeout: f32) {
        (self
            .vsl_client_set_timeout
            .as_ref()
            .expect("Expected function, got error."))(client, timeout)
    }
    #[doc = " Creates and posts the video frame along with optional user pointer to any\n arbitrary data.  Typically it would be used for holding a reference to\n the host's view of the frame handle.\n\n @deprecated The vsl_frame_register function is deprecated in favour of using\n the @ref vsl_frame_init(), @ref vsl_frame_alloc() or @ref vsl_frame_attach(),\n and @ref vsl_host_post() functions which separate frame creation from posting\n to the host for publishing to subscribers.\n\n @note A frame created through this function is owned by the host and should\n not have @ref vsl_frame_release called on it.  This will be managed by the\n host on frame expiry.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_register(
        &self,
        host: *mut VSLHost,
        serial: i64,
        handle: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fourcc: u32,
        size: usize,
        offset: usize,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
        cleanup: vsl_frame_cleanup,
        userptr: *mut ::std::os::raw::c_void,
    ) -> *mut VSLFrame {
        (self
            .vsl_frame_register
            .as_ref()
            .expect("Expected function, got error."))(
            host, serial, handle, width, height, fourcc, size, offset, expires, duration, pts, dts,
            cleanup, userptr,
        )
    }
    #[doc = " Initializes a VSLFrame without underlying frame buffer.  To create the\n backing memory either call @ref vsl_frame_alloc() or to attach to an existing\n bufer use @ref vsl_frame_attach().\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_init(
        &self,
        width: u32,
        height: u32,
        stride: u32,
        fourcc: u32,
        userptr: *mut ::std::os::raw::c_void,
        cleanup: vsl_frame_cleanup,
    ) -> *mut VSLFrame {
        (self
            .vsl_frame_init
            .as_ref()
            .expect("Expected function, got error."))(
            width, height, stride, fourcc, userptr, cleanup,
        )
    }
    #[doc = " Allocates the underlying memory for the frame.  This function will prefer to\n allocate using dmabuf and fallback to shared memory if dmabuf is not\n available, unless the frame has a path defined in which case shared memory is\n assumed.  If the path begins with /dev then it assumed to point to a\n dmabuf-heap device.  If path is NULL then the allocator will first attempt to\n create a dmabuf then fallback to shared memory.\n\n Allocations will be based on a buffer large enough to hold height*stride\n bytes.  If using a compressed fourcc such as JPEG the actual data will be\n smaller, this size can be captured when calling @ref vsl_frame_copy() as the\n function returns the number of bytes copied into the target frame.  There is\n currently no method to capture the actual compressed size when receiving an\n already compressed frame.  This limitation is because the size varies from\n frame to frame while the underlying buffer is of a fixed size.  When the\n actual encoded size is important, the @ref vsl_frame_copy() should be called\n directly or the reported size communicated to the client through a separate\n channel.\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_alloc(
        &self,
        frame: *mut VSLFrame,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_alloc
            .as_ref()
            .expect("Expected function, got error."))(frame, path)
    }
    #[doc = " Frees the allocated buffer for this frame.  Does not release the frame itself\n for that use @ref vsl_frame_release().\n\n @param frame\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unalloc(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_unalloc
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attach the provided file descriptor to the VSLFrame.  If size is not provided\n it is assumed to be stride*height bytes.  If offset is provided then size\n *MUST* be provided, the offset is in bytes to the start of the frame.\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_attach(
        &self,
        frame: *mut VSLFrame,
        fd: ::std::os::raw::c_int,
        size: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_attach
            .as_ref()
            .expect("Expected function, got error."))(frame, fd, size, offset)
    }
    #[doc = " Returns the path to the underlying VSLFrame buffer.  Note it will not always\n be available, such as when the frame was externally created.  When no path is\n available NULL is returned.\n\n @note This function is not thread-safe and you must use the string\n immediately.\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_path(&self, frame: *const VSLFrame) -> *const ::std::os::raw::c_char {
        (self
            .vsl_frame_path
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Unregisters the frame, removing it from the host pool.\n\n @deprecated This function is deprecated in favour of calling\n @ref vsl_frame_release() which will handle the required cleanup.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unregister(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_unregister
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Copy the source frame into the target frame, with optional source crop. The\n copy handles format conversion, rescaling to fit the target frame.  Resize\n happens after the crop, if required.\n\n Copy can happen between any frames, regardless of whether they are parented\n or not or have differing parents.  The copy happens through the underlying\n buffers and will attempt to use available hardware accelerators.\n\n The function will attempt to lock target and source.  Since lock is a no-op\n when not a client frame it is safe even for free-standing frames.  Copying to\n or from a posted frame is safe but is likely to cause visual corruption such\n as tearing.\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_copy(
        &self,
        target: *mut VSLFrame,
        source: *mut VSLFrame,
        crop: *const VSLRect,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_copy
            .as_ref()
            .expect("Expected function, got error."))(target, source, crop)
    }
    #[doc = " Returns the user pointer associated with this frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_userptr(&self, frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_frame_userptr
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Associate userptr with this frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_set_userptr(
        &self,
        frame: *mut VSLFrame,
        userptr: *mut ::std::os::raw::c_void,
    ) {
        (self
            .vsl_frame_set_userptr
            .as_ref()
            .expect("Expected function, got error."))(frame, userptr)
    }
    #[doc = " Waits for a frame to arrive and returns a new frame object.  Frames who's\n timestamp is less than @param until will be ignored.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_wait(&self, client: *mut VSLClient, until: i64) -> *mut VSLFrame {
        (self
            .vsl_frame_wait
            .as_ref()
            .expect("Expected function, got error."))(client, until)
    }
    #[doc = " Releases the frame, performing required cleanup.  If the frame was mapped it\n will be unmapped.  If the frame was posted to a host it will be removed, if\n this is a client frame it will be unlocked.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_release(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_release
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attempts to lock the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_trylock(&self, frame: *mut VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_trylock
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attempts to unlock the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unlock(&self, frame: *mut VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_unlock
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the serial frame count of the video frame.\n\n Note this frame serial tracks the count of frames registered on the host and\n does not necessarily equal the actual frame number from the camera.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_serial(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_serial
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_timestamp(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_timestamp
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the duration for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_duration(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_duration
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the presentation timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_pts(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_pts
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the decode timestamp for this frame in nanoseconds.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_dts(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_dts
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the epiration time for this frame in milliseconds.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_expires(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_expires
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the FOURCC code for the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_fourcc(&self, frame: *const VSLFrame) -> u32 {
        (self
            .vsl_frame_fourcc
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the width in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_width(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_width
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the height in pixels of the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_height(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_height
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the stride in bytes of the video frame, to go from one row to the\n next.\n\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_stride(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_stride
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the size in bytes of the video frame.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_size(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_size
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the file descriptor for this frame or -1 if none is associated.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_handle(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_handle
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the physical address of the frame.  If the frame does not support\n DMA then MMAP_FAILED is returned.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_paddr(&self, frame: *const VSLFrame) -> isize {
        (self
            .vsl_frame_paddr
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.  Ensure the frame is\n unmapped when no longer needed using @ref nn_frame_munmap().\n\n Note that a frame must be locked for the duration of the mapping.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_mmap(
        &self,
        frame: *mut VSLFrame,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_frame_mmap
            .as_ref()
            .expect("Expected function, got error."))(frame, size)
    }
    #[doc = " Maps the frame into the process' memory space, optionally also sets the\n size of the frame if @param size is non-NULL.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_munmap(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_munmap
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Cache synchronization session control for when using DMA-backed buffers.\n This happens automatically on mmap/munmap but the API is also available for\n cases where the frame is updated in-place during a mapping.\n\n @param frame the frame object to synchronize\n @param enable whether the sync session is being enabled or disabled\n @param mode the synchronization mode controls READ, WRITE, or both.\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_sync(
        &self,
        frame: *const VSLFrame,
        enable: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_sync
            .as_ref()
            .expect("Expected function, got error."))(frame, enable, mode)
    }
    #[doc = " Returns a fourcc integer code from the string.  If the fourcc code is invalid\n or unsupported then 0 is returned."]
    pub unsafe fn vsl_fourcc_from_string(&self, fourcc: *const ::std::os::raw::c_char) -> u32 {
        (self
            .vsl_fourcc_from_string
            .as_ref()
            .expect("Expected function, got error."))(fourcc)
    }
    #[doc = " @brief Creates VSLEncoder instance\n\n @param profile VSLEncoderProfile determining encode quality\n @param outputFourcc fourcc code defining the codec\n @param fps output stream fps\n @return VSLEncoder* new encoder instance\n\n Every encoder instance must be released using vsl_encoder_release\n\n For Hantro VC8000e encoder initialization is performed when vsl_encode_frame\n is called for a first time"]
    pub unsafe fn vsl_encoder_create(
        &self,
        profile: VSLEncoderProfile,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
    ) -> *mut VSLEncoder {
        (self
            .vsl_encoder_create
            .as_ref()
            .expect("Expected function, got error."))(profile, outputFourcc, fps)
    }
    #[doc = " @brief Destroys VSLEncoder instance\n\n @param encoder VSLEncoder* instance to destroy"]
    pub unsafe fn vsl_encoder_release(&self, encoder: *mut VSLEncoder) {
        (self
            .vsl_encoder_release
            .as_ref()
            .expect("Expected function, got error."))(encoder)
    }
    #[doc = " @brief Encode frame\n @param encoder VSLEncoder instance\n @param source VSLFrame source\n @param destination VSLFrame destination\n @param cropRegion (optional) VSLRect that defines the crop region, NULL when\n destination and source sizes match\n @param keyframe (optional) VSL sets this to 1 if the encoded frame is a\n keyframe, otherwise 0. User can set to NULL to ignore param.\n @retval 0 on success\n @retval -1 on falure (check errno for details)\n\n For Hantro VC8000e encoder initialization is performed when this function is\n called for a first time For Hantro VC8000e encoder source width, height and\n fourcc; destination width, height and fourcc; cropRegion parameters must\n match for all function calls throughout the lifetime of the encoder instance"]
    pub unsafe fn vsl_encode_frame(
        &self,
        encoder: *mut VSLEncoder,
        source: *mut VSLFrame,
        destination: *mut VSLFrame,
        cropRegion: *const VSLRect,
        keyframe: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_encode_frame
            .as_ref()
            .expect("Expected function, got error."))(
            encoder,
            source,
            destination,
            cropRegion,
            keyframe,
        )
    }
    pub unsafe fn vsl_encoder_new_output_frame(
        &self,
        encoder: *const VSLEncoder,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> *mut VSLFrame {
        (self
            .vsl_encoder_new_output_frame
            .as_ref()
            .expect("Expected function, got error."))(
            encoder, width, height, duration, pts, dts
        )
    }
    #[doc = " Opens the camera device specified by the @param filename and allocates\n device memory. If the device was not found or could not be recognized\n\n Return NULL if the device was not found or could not be recognized.\n Otherwise returns a vsl_camera context which can be used in other vsl_camera\n functions.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_open_device(
        &self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut vsl_camera {
        (self
            .vsl_camera_open_device
            .as_ref()
            .expect("Expected function, got error."))(filename)
    }
    #[doc = " Initialized the camera device in @param ctx for streaming\n and allocate camera buffers.\n\n Then requests the camera to stream at the requested @param width\n and @param height using the requested @param fourcc code.\n\n If @param width, @param height, or @param fourcc are 0, the respective value\n use the default provided by the driver\n\n The @param width, @param height, @param fourcc parameters\n will be set to the actual width and height and fourcc that\n the camera driver sets the device to.\n\n Returns -1 if an error is encountered when initializing the camera to stream,\n otherwise returns 0\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_init_device(
        &self,
        ctx: *mut vsl_camera,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        buf_count: *mut ::std::os::raw::c_int,
        fourcc: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_init_device
            .as_ref()
            .expect("Expected function, got error."))(ctx, width, height, buf_count, fourcc)
    }
    #[doc = " Requests the camera in @param ctx to mirror the image leftside right\n\n Returns -1 if a mirror was requested but the camera driver refused\n the request, otherwise 0.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_mirror(
        &self,
        ctx: *const vsl_camera,
        mirror: bool,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_mirror
            .as_ref()
            .expect("Expected function, got error."))(ctx, mirror)
    }
    #[doc = " Requests the camera in @param ctx to mirror the image upside down\n\n Returns -1 if a mirror was requested but the camera driver refused\n the request, otherwise 0.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_mirror_v(
        &self,
        ctx: *const vsl_camera,
        mirror: bool,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_mirror_v
            .as_ref()
            .expect("Expected function, got error."))(ctx, mirror)
    }
    #[doc = " Starts the camera stream.\n\n Must be called after @ref vsl_camera_init_device\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_start_capturing(&self, ctx: *mut vsl_camera) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_start_capturing
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Attempts to read a frame from the camera.\n\n Must be called after @ref vsl_camera_start_capturing.\n\n Ensure to call @ref vsl_camera_release_buffer after the buffer is done being\n used and allow the buffer to be reused for frame capture.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_get_data(&self, ctx: *mut vsl_camera) -> *mut vsl_camera_buffer {
        (self
            .vsl_camera_get_data
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Enqueues a buffer to be reused for frame capture.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_release_buffer(
        &self,
        ctx: *mut vsl_camera,
        buffer: *const vsl_camera_buffer,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_release_buffer
            .as_ref()
            .expect("Expected function, got error."))(ctx, buffer)
    }
    #[doc = " Stops the camera stream.\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_stop_capturing(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_stop_capturing
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Uninitializes the camera buffers and frees the buffer memory\n\n Ensure that the device is not streaming. If\n @ref vsl_camera_start_capturing was called, ensure that\n @ref vsl_camera_stop_capturing is called before this function\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_uninit_device(&self, ctx: *mut vsl_camera) {
        (self
            .vsl_camera_uninit_device
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Closes the camera device and frees the device memory\n\n Ensure that the device is not streaming. If\n @ref vsl_camera_start_capturing was called, ensure that\n @ref vsl_camera_stop_capturing is called before this function\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_close_device(&self, ctx: *mut vsl_camera) {
        (self
            .vsl_camera_close_device
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Checks if dma buffers are supported on the camera\n\n Ensure that this is called after\n @ref vsl_camera_init_device\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_is_dmabuf_supported(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_is_dmabuf_supported
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Returns the number of queued buffers for the camera.\n @ref vsl_camera_get_data will timeout if there are 0 queued buffers.\n\n The user can send buffers back to the buffer queue using\n @ref vsl_camera_release_buffer\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_get_queued_buf_count(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_get_queued_buf_count
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Returns the mmap memory of the camera buffer\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_mmap(
        &self,
        buffer: *mut vsl_camera_buffer,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_camera_buffer_mmap
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the dmabuf file descriptor of the camera buffer\n\n If the device does not support dmabuf, returns -1\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_dma_fd(
        &self,
        buffer: *const vsl_camera_buffer,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_buffer_dma_fd
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the phys addr of the camera buffer\n\n If the device does not support physical address, returns 0\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_phys_addr(&self, buffer: *const vsl_camera_buffer) -> u64 {
        (self
            .vsl_camera_buffer_phys_addr
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the length of the camera buffer in bytes\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_length(&self, buffer: *const vsl_camera_buffer) -> u32 {
        (self
            .vsl_camera_buffer_length
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the fourcc code of the camera buffer\n\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_fourcc(&self, buffer: *const vsl_camera_buffer) -> u32 {
        (self
            .vsl_camera_buffer_fourcc
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Reads the timestamp of the camera buffer into @param seconds and @param\n nanoseconds.  The seconds are relative to the monotonic time when the frame\n was captured, nanoseconds are the sub-seconds in nanoseconds."]
    pub unsafe fn vsl_camera_buffer_timestamp(
        &self,
        buffer: *const vsl_camera_buffer,
        seconds: *mut i64,
        nanoseconds: *mut i64,
    ) {
        (self
            .vsl_camera_buffer_timestamp
            .as_ref()
            .expect("Expected function, got error."))(buffer, seconds, nanoseconds)
    }
    #[doc = " Lists the supported single planar formats of\n the camera into @param codes as fourcc codes"]
    pub unsafe fn vsl_camera_enum_fmts(
        &self,
        ctx: *const vsl_camera,
        codes: *mut u32,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_enum_fmts
            .as_ref()
            .expect("Expected function, got error."))(ctx, codes, size)
    }
    #[doc = " Lists the supported multi planar formats of\n the camera into @param codes as fourcc codes"]
    pub unsafe fn vsl_camera_enum_mplane_fmts(
        &self,
        ctx: *const vsl_camera,
        codes: *mut u32,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_enum_mplane_fmts
            .as_ref()
            .expect("Expected function, got error."))(ctx, codes, size)
    }
    pub unsafe fn vsl_decoder_create(
        &self,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
    ) -> *mut VSLDecoder {
        (self
            .vsl_decoder_create
            .as_ref()
            .expect("Expected function, got error."))(outputFourcc, fps)
    }
    pub unsafe fn vsl_decode_frame(
        &self,
        decoder: *mut VSLDecoder,
        data: *const ::std::os::raw::c_void,
        data_length: ::std::os::raw::c_uint,
        bytes_used: *mut usize,
        output_frame: *mut *mut VSLFrame,
    ) -> VSLDecoderRetCode {
        (self
            .vsl_decode_frame
            .as_ref()
            .expect("Expected function, got error."))(
            decoder,
            data,
            data_length,
            bytes_used,
            output_frame,
        )
    }
    pub unsafe fn vsl_decoder_width(&self, decoder: *const VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_width
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    pub unsafe fn vsl_decoder_height(&self, decoder: *const VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_height
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    pub unsafe fn vsl_decoder_crop(&self, decoder: *const VSLDecoder) -> VSLRect {
        (self
            .vsl_decoder_crop
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    pub unsafe fn vsl_decoder_release(&self, decoder: *mut VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_release
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
}
