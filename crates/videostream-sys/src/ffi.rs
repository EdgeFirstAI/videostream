// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 Au-Zone Technologies
//
/* automatically generated by rust-bindgen 0.72.1 */

pub const VSL_VERSION: &[u8; 6] = b"2.0.0\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_host {
    _unused: [u8; 0],
}
#[doc = " @struct VSLHost\n @brief The VSLHost object manages a connection point at the user-defined path\n and allows frames to be registered for client use."]
pub type VSLHost = vsl_host;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_client {
    _unused: [u8; 0],
}
#[doc = " @struct VSLClient\n @brief The VSLClient object manages a single connection to a VSLHost."]
pub type VSLClient = vsl_client;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_frame {
    _unused: [u8; 0],
}
#[doc = " @struct VSLFrame\n @brief The VSLFrame object represents a single video frame from either the\n host or client perspective.  Certain API are only available to the host or\n client."]
pub type VSLFrame = vsl_frame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_encoder {
    _unused: [u8; 0],
}
#[doc = " @struct VSLEncoder\n @brief The VSLEncoder object represents encoder instance.\n"]
pub type VSLEncoder = vsl_encoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_decoder {
    _unused: [u8; 0],
}
#[doc = " @struct VSLDecoder\n @brief The VSLDecoder object represents decoder instance.\n"]
pub type VSLDecoder = vsl_decoder;
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_rect {
    #[doc = " The left-most pixel offset for the rectangle."]
    pub x: ::std::os::raw::c_int,
    #[doc = " The top-most pixel offset for the rectangle."]
    pub y: ::std::os::raw::c_int,
    #[doc = " The width in pixels of the rectangle.  The end position is x+width."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height in pixels of the rectangle.  The end position is y+height."]
    pub height: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vsl_rect"][::std::mem::size_of::<vsl_rect>() - 16usize];
    ["Alignment of vsl_rect"][::std::mem::align_of::<vsl_rect>() - 4usize];
    ["Offset of field: vsl_rect::x"][::std::mem::offset_of!(vsl_rect, x) - 0usize];
    ["Offset of field: vsl_rect::y"][::std::mem::offset_of!(vsl_rect, y) - 4usize];
    ["Offset of field: vsl_rect::width"][::std::mem::offset_of!(vsl_rect, width) - 8usize];
    ["Offset of field: vsl_rect::height"][::std::mem::offset_of!(vsl_rect, height) - 12usize];
};
#[doc = " The VSLRect structure represents a rectangle region of a frame and is used to\n define cropping regions for sub-frames."]
pub type VSLRect = vsl_rect;
#[doc = " Automatic bitrate selection (encoder default).\n\n Platform and version dependent. Testing shows approximately 10000 kbps\n on i.MX8M Plus. Use this for general-purpose encoding when specific\n bitrate control is not required."]
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_AUTO: vsl_encode_profile = 0;
#[doc = " 5 Mbps target bitrate.\n\n Suitable for moderate quality 1080p video or high quality 720p."]
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_5000_KBPS: vsl_encode_profile = 1;
#[doc = " 25 Mbps target bitrate.\n\n Suitable for high quality 1080p video or moderate quality 4K."]
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_25000_KBPS: vsl_encode_profile = 2;
#[doc = " 50 Mbps target bitrate.\n\n Suitable for very high quality 1080p or high quality 4K video."]
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_50000_KBPS: vsl_encode_profile = 3;
#[doc = " 100 Mbps target bitrate.\n\n Suitable for maximum quality 4K video or when preserving fine details\n is critical. May stress storage and network bandwidth."]
pub const vsl_encode_profile_VSL_ENCODE_PROFILE_100000_KBPS: vsl_encode_profile = 4;
#[doc = " Encoder profile defining target bitrate for video encoding.\n\n These profiles provide a convenient way to specify encoding quality/bitrate\n tradeoffs. Higher bitrates produce better quality at the cost of larger file\n sizes and potentially higher CPU/power consumption.\n\n @note The actual quality-to-bitrate ratio depends on the codec (H.264 vs\n H.265), encoder implementation, and content complexity."]
pub type vsl_encode_profile = ::std::os::raw::c_uint;
#[doc = " Encoder profile defining target bitrate for video encoding.\n\n These profiles provide a convenient way to specify encoding quality/bitrate\n tradeoffs. Higher bitrates produce better quality at the cost of larger file\n sizes and potentially higher CPU/power consumption.\n\n @note The actual quality-to-bitrate ratio depends on the codec (H.264 vs\n H.265), encoder implementation, and content complexity."]
pub use self::vsl_encode_profile as VSLEncoderProfile;
#[doc = " H.264/AVC (Advanced Video Coding) codec.\n\n Widely supported standard (ISO/IEC 14496-10, ITU-T H.264) with good\n compression and compatibility. Recommended for maximum device\n compatibility."]
pub const VSLDecoderCodec_VSL_DEC_H264: VSLDecoderCodec = 0;
#[doc = " H.265/HEVC (High Efficiency Video Coding) codec.\n\n Next-generation standard (ISO/IEC 23008-2, ITU-T H.265) providing\n approximately 50% better compression than H.264 at equivalent quality.\n Recommended when bandwidth/storage are constrained and decoder support\n is confirmed."]
pub const VSLDecoderCodec_VSL_DEC_HEVC: VSLDecoderCodec = 1;
#[doc = " Video codec type for hardware decoder.\n\n Specifies which video compression standard to use for decoding.\n Both codecs are supported via Hantro VPU hardware acceleration on i.MX8."]
pub type VSLDecoderCodec = ::std::os::raw::c_uint;
#[doc = " Auto-detect best available backend.\n\n Selection priority:\n 1. Check VSL_CODEC_BACKEND environment variable\n 2. Prefer V4L2 if device available and has M2M capability\n 3. Fall back to Hantro if V4L2 unavailable\n 4. Fail if no backend available"]
pub const VSLCodecBackend_VSL_CODEC_BACKEND_AUTO: VSLCodecBackend = 0;
#[doc = " Force Hantro/libcodec.so backend.\n\n Uses the proprietary VPU wrapper library. May be needed for:\n - Systems without V4L2 codec driver\n - Testing/debugging Hantro-specific behavior\n - Compatibility with older configurations"]
pub const VSLCodecBackend_VSL_CODEC_BACKEND_HANTRO: VSLCodecBackend = 1;
#[doc = " Force V4L2 kernel driver backend.\n\n Uses the vsi_v4l2 mem2mem driver. Provides:\n - 37-56x faster decode performance\n - Stable encoder (vs crashing libcodec.so)\n - Standard Linux API"]
pub const VSLCodecBackend_VSL_CODEC_BACKEND_V4L2: VSLCodecBackend = 2;
#[doc = " Codec backend selection for encoder/decoder.\n\n Allows selection between V4L2 kernel driver and Hantro user-space\n library (libcodec.so) backends. Use with vsl_decoder_create_ex() and\n vsl_encoder_create_ex() for explicit backend control.\n\n The VSL_CODEC_BACKEND environment variable can override the AUTO selection:\n - \"hantro\" - Force Hantro backend even if V4L2 available\n - \"v4l2\"   - Force V4L2 backend (fail if unavailable)\n - \"auto\"   - Auto-detect (default)\n\n @since 2.0"]
pub type VSLCodecBackend = ::std::os::raw::c_uint;
#[doc = " Function pointer definition which will be called as part of\n @ref vsl_frame_unregister.  This is typically used to free resources\n associated with the frame on either client or host side."]
pub type vsl_frame_cleanup = ::std::option::Option<unsafe extern "C" fn(frame: *mut VSLFrame)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_camera_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_camera {
    _unused: [u8; 0],
}
pub const VSLDecoderRetCode_VSL_DEC_SUCCESS: VSLDecoderRetCode = 0;
pub const VSLDecoderRetCode_VSL_DEC_ERR: VSLDecoderRetCode = 1;
pub const VSLDecoderRetCode_VSL_DEC_INIT_INFO: VSLDecoderRetCode = 2;
pub const VSLDecoderRetCode_VSL_DEC_FRAME_DEC: VSLDecoderRetCode = 4;
pub type VSLDecoderRetCode = ::std::os::raw::c_uint;
pub struct VideoStreamLibrary {
    __library: ::libloading::Library,
    pub vsl_version:
        Result<unsafe extern "C" fn() -> *const ::std::os::raw::c_char, ::libloading::Error>,
    pub vsl_timestamp: Result<unsafe extern "C" fn() -> i64, ::libloading::Error>,
    pub vsl_host_init: Result<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char) -> *mut VSLHost,
        ::libloading::Error,
    >,
    pub vsl_host_release: Result<unsafe extern "C" fn(host: *mut VSLHost), ::libloading::Error>,
    pub vsl_host_path: Result<
        unsafe extern "C" fn(host: *const VSLHost) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_host_poll: Result<
        unsafe extern "C" fn(host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_service: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            sock: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_process: Result<
        unsafe extern "C" fn(host: *mut VSLHost) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_sockets: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            n_sockets: usize,
            sockets: *mut ::std::os::raw::c_int,
            max_sockets: *mut usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_post: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            frame: *mut VSLFrame,
            expires: i64,
            duration: i64,
            pts: i64,
            dts: i64,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_host_drop: Result<
        unsafe extern "C" fn(host: *mut VSLHost, frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_client_init: Result<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            userptr: *mut ::std::os::raw::c_void,
            reconnect: bool,
        ) -> *mut VSLClient,
        ::libloading::Error,
    >,
    pub vsl_client_release:
        Result<unsafe extern "C" fn(client: *mut VSLClient), ::libloading::Error>,
    pub vsl_client_disconnect:
        Result<unsafe extern "C" fn(client: *mut VSLClient), ::libloading::Error>,
    pub vsl_client_userptr: Result<
        unsafe extern "C" fn(client: *mut VSLClient) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_client_path: Result<
        unsafe extern "C" fn(client: *const VSLClient) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_client_set_timeout:
        Result<unsafe extern "C" fn(client: *mut VSLClient, timeout: f32), ::libloading::Error>,
    pub vsl_frame_register: Result<
        unsafe extern "C" fn(
            host: *mut VSLHost,
            serial: i64,
            handle: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            fourcc: u32,
            size: usize,
            offset: usize,
            expires: i64,
            duration: i64,
            pts: i64,
            dts: i64,
            cleanup: vsl_frame_cleanup,
            userptr: *mut ::std::os::raw::c_void,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_init: Result<
        unsafe extern "C" fn(
            width: u32,
            height: u32,
            stride: u32,
            fourcc: u32,
            userptr: *mut ::std::os::raw::c_void,
            cleanup: vsl_frame_cleanup,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_alloc: Result<
        unsafe extern "C" fn(
            frame: *mut VSLFrame,
            path: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_unalloc: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_attach: Result<
        unsafe extern "C" fn(
            frame: *mut VSLFrame,
            fd: ::std::os::raw::c_int,
            size: usize,
            offset: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_path: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub vsl_frame_unregister:
        Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_copy: Result<
        unsafe extern "C" fn(
            target: *mut VSLFrame,
            source: *mut VSLFrame,
            crop: *const VSLRect,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_userptr: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_frame_set_userptr: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame, userptr: *mut ::std::os::raw::c_void),
        ::libloading::Error,
    >,
    pub vsl_frame_wait: Result<
        unsafe extern "C" fn(client: *mut VSLClient, until: i64) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_frame_release: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_trylock: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_unlock: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_serial:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_timestamp:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_duration:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_pts:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_dts:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_expires:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> i64, ::libloading::Error>,
    pub vsl_frame_fourcc:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> u32, ::libloading::Error>,
    pub vsl_frame_width: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_height: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_stride: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_size: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_handle: Result<
        unsafe extern "C" fn(frame: *const VSLFrame) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_frame_paddr:
        Result<unsafe extern "C" fn(frame: *const VSLFrame) -> isize, ::libloading::Error>,
    pub vsl_frame_mmap: Result<
        unsafe extern "C" fn(frame: *mut VSLFrame, size: *mut usize) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_frame_munmap: Result<unsafe extern "C" fn(frame: *mut VSLFrame), ::libloading::Error>,
    pub vsl_frame_sync: Result<
        unsafe extern "C" fn(
            frame: *const VSLFrame,
            enable: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_fourcc_from_string: Result<
        unsafe extern "C" fn(fourcc: *const ::std::os::raw::c_char) -> u32,
        ::libloading::Error,
    >,
    pub vsl_encoder_create: Result<
        unsafe extern "C" fn(
            profile: VSLEncoderProfile,
            outputFourcc: u32,
            fps: ::std::os::raw::c_int,
        ) -> *mut VSLEncoder,
        ::libloading::Error,
    >,
    pub vsl_encoder_create_ex: Result<
        unsafe extern "C" fn(
            profile: VSLEncoderProfile,
            outputFourcc: u32,
            fps: ::std::os::raw::c_int,
            backend: VSLCodecBackend,
        ) -> *mut VSLEncoder,
        ::libloading::Error,
    >,
    pub vsl_encoder_release:
        Result<unsafe extern "C" fn(encoder: *mut VSLEncoder), ::libloading::Error>,
    pub vsl_encode_frame: Result<
        unsafe extern "C" fn(
            encoder: *mut VSLEncoder,
            source: *mut VSLFrame,
            destination: *mut VSLFrame,
            cropRegion: *const VSLRect,
            keyframe: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_encoder_new_output_frame: Result<
        unsafe extern "C" fn(
            encoder: *const VSLEncoder,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            duration: i64,
            pts: i64,
            dts: i64,
        ) -> *mut VSLFrame,
        ::libloading::Error,
    >,
    pub vsl_camera_open_device: Result<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut vsl_camera,
        ::libloading::Error,
    >,
    pub vsl_camera_init_device: Result<
        unsafe extern "C" fn(
            ctx: *mut vsl_camera,
            width: *mut ::std::os::raw::c_int,
            height: *mut ::std::os::raw::c_int,
            buf_count: *mut ::std::os::raw::c_int,
            fourcc: *mut u32,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_mirror: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera, mirror: bool) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_mirror_v: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera, mirror: bool) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_start_capturing: Result<
        unsafe extern "C" fn(ctx: *mut vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_get_data: Result<
        unsafe extern "C" fn(ctx: *mut vsl_camera) -> *mut vsl_camera_buffer,
        ::libloading::Error,
    >,
    pub vsl_camera_release_buffer: Result<
        unsafe extern "C" fn(
            ctx: *mut vsl_camera,
            buffer: *const vsl_camera_buffer,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_stop_capturing: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_uninit_device:
        Result<unsafe extern "C" fn(ctx: *mut vsl_camera), ::libloading::Error>,
    pub vsl_camera_close_device:
        Result<unsafe extern "C" fn(ctx: *mut vsl_camera), ::libloading::Error>,
    pub vsl_camera_is_dmabuf_supported: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_get_queued_buf_count: Result<
        unsafe extern "C" fn(ctx: *const vsl_camera) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_mmap: Result<
        unsafe extern "C" fn(buffer: *mut vsl_camera_buffer) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_dma_fd: Result<
        unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_buffer_phys_addr:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u64, ::libloading::Error>,
    pub vsl_camera_buffer_length:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u32, ::libloading::Error>,
    pub vsl_camera_buffer_fourcc:
        Result<unsafe extern "C" fn(buffer: *const vsl_camera_buffer) -> u32, ::libloading::Error>,
    pub vsl_camera_buffer_timestamp: Result<
        unsafe extern "C" fn(
            buffer: *const vsl_camera_buffer,
            seconds: *mut i64,
            nanoseconds: *mut i64,
        ),
        ::libloading::Error,
    >,
    pub vsl_camera_enum_fmts: Result<
        unsafe extern "C" fn(
            ctx: *const vsl_camera,
            codes: *mut u32,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_camera_enum_mplane_fmts: Result<
        unsafe extern "C" fn(
            ctx: *const vsl_camera,
            codes: *mut u32,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_create: Result<
        unsafe extern "C" fn(codec: VSLDecoderCodec, fps: ::std::os::raw::c_int) -> *mut VSLDecoder,
        ::libloading::Error,
    >,
    pub vsl_decoder_create_ex: Result<
        unsafe extern "C" fn(
            codec: u32,
            fps: ::std::os::raw::c_int,
            backend: VSLCodecBackend,
        ) -> *mut VSLDecoder,
        ::libloading::Error,
    >,
    pub vsl_decode_frame: Result<
        unsafe extern "C" fn(
            decoder: *mut VSLDecoder,
            data: *const ::std::os::raw::c_void,
            data_length: ::std::os::raw::c_uint,
            bytes_used: *mut usize,
            output_frame: *mut *mut VSLFrame,
        ) -> VSLDecoderRetCode,
        ::libloading::Error,
    >,
    pub vsl_decoder_width: Result<
        unsafe extern "C" fn(decoder: *const VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_height: Result<
        unsafe extern "C" fn(decoder: *const VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub vsl_decoder_crop:
        Result<unsafe extern "C" fn(decoder: *const VSLDecoder) -> VSLRect, ::libloading::Error>,
    pub vsl_decoder_release: Result<
        unsafe extern "C" fn(decoder: *mut VSLDecoder) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
}
impl VideoStreamLibrary {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: ::libloading::AsFilename,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let vsl_version = __library.get(b"vsl_version\0").map(|sym| *sym);
        let vsl_timestamp = __library.get(b"vsl_timestamp\0").map(|sym| *sym);
        let vsl_host_init = __library.get(b"vsl_host_init\0").map(|sym| *sym);
        let vsl_host_release = __library.get(b"vsl_host_release\0").map(|sym| *sym);
        let vsl_host_path = __library.get(b"vsl_host_path\0").map(|sym| *sym);
        let vsl_host_poll = __library.get(b"vsl_host_poll\0").map(|sym| *sym);
        let vsl_host_service = __library.get(b"vsl_host_service\0").map(|sym| *sym);
        let vsl_host_process = __library.get(b"vsl_host_process\0").map(|sym| *sym);
        let vsl_host_sockets = __library.get(b"vsl_host_sockets\0").map(|sym| *sym);
        let vsl_host_post = __library.get(b"vsl_host_post\0").map(|sym| *sym);
        let vsl_host_drop = __library.get(b"vsl_host_drop\0").map(|sym| *sym);
        let vsl_client_init = __library.get(b"vsl_client_init\0").map(|sym| *sym);
        let vsl_client_release = __library.get(b"vsl_client_release\0").map(|sym| *sym);
        let vsl_client_disconnect = __library.get(b"vsl_client_disconnect\0").map(|sym| *sym);
        let vsl_client_userptr = __library.get(b"vsl_client_userptr\0").map(|sym| *sym);
        let vsl_client_path = __library.get(b"vsl_client_path\0").map(|sym| *sym);
        let vsl_client_set_timeout = __library.get(b"vsl_client_set_timeout\0").map(|sym| *sym);
        let vsl_frame_register = __library.get(b"vsl_frame_register\0").map(|sym| *sym);
        let vsl_frame_init = __library.get(b"vsl_frame_init\0").map(|sym| *sym);
        let vsl_frame_alloc = __library.get(b"vsl_frame_alloc\0").map(|sym| *sym);
        let vsl_frame_unalloc = __library.get(b"vsl_frame_unalloc\0").map(|sym| *sym);
        let vsl_frame_attach = __library.get(b"vsl_frame_attach\0").map(|sym| *sym);
        let vsl_frame_path = __library.get(b"vsl_frame_path\0").map(|sym| *sym);
        let vsl_frame_unregister = __library.get(b"vsl_frame_unregister\0").map(|sym| *sym);
        let vsl_frame_copy = __library.get(b"vsl_frame_copy\0").map(|sym| *sym);
        let vsl_frame_userptr = __library.get(b"vsl_frame_userptr\0").map(|sym| *sym);
        let vsl_frame_set_userptr = __library.get(b"vsl_frame_set_userptr\0").map(|sym| *sym);
        let vsl_frame_wait = __library.get(b"vsl_frame_wait\0").map(|sym| *sym);
        let vsl_frame_release = __library.get(b"vsl_frame_release\0").map(|sym| *sym);
        let vsl_frame_trylock = __library.get(b"vsl_frame_trylock\0").map(|sym| *sym);
        let vsl_frame_unlock = __library.get(b"vsl_frame_unlock\0").map(|sym| *sym);
        let vsl_frame_serial = __library.get(b"vsl_frame_serial\0").map(|sym| *sym);
        let vsl_frame_timestamp = __library.get(b"vsl_frame_timestamp\0").map(|sym| *sym);
        let vsl_frame_duration = __library.get(b"vsl_frame_duration\0").map(|sym| *sym);
        let vsl_frame_pts = __library.get(b"vsl_frame_pts\0").map(|sym| *sym);
        let vsl_frame_dts = __library.get(b"vsl_frame_dts\0").map(|sym| *sym);
        let vsl_frame_expires = __library.get(b"vsl_frame_expires\0").map(|sym| *sym);
        let vsl_frame_fourcc = __library.get(b"vsl_frame_fourcc\0").map(|sym| *sym);
        let vsl_frame_width = __library.get(b"vsl_frame_width\0").map(|sym| *sym);
        let vsl_frame_height = __library.get(b"vsl_frame_height\0").map(|sym| *sym);
        let vsl_frame_stride = __library.get(b"vsl_frame_stride\0").map(|sym| *sym);
        let vsl_frame_size = __library.get(b"vsl_frame_size\0").map(|sym| *sym);
        let vsl_frame_handle = __library.get(b"vsl_frame_handle\0").map(|sym| *sym);
        let vsl_frame_paddr = __library.get(b"vsl_frame_paddr\0").map(|sym| *sym);
        let vsl_frame_mmap = __library.get(b"vsl_frame_mmap\0").map(|sym| *sym);
        let vsl_frame_munmap = __library.get(b"vsl_frame_munmap\0").map(|sym| *sym);
        let vsl_frame_sync = __library.get(b"vsl_frame_sync\0").map(|sym| *sym);
        let vsl_fourcc_from_string = __library.get(b"vsl_fourcc_from_string\0").map(|sym| *sym);
        let vsl_encoder_create = __library.get(b"vsl_encoder_create\0").map(|sym| *sym);
        let vsl_encoder_create_ex = __library.get(b"vsl_encoder_create_ex\0").map(|sym| *sym);
        let vsl_encoder_release = __library.get(b"vsl_encoder_release\0").map(|sym| *sym);
        let vsl_encode_frame = __library.get(b"vsl_encode_frame\0").map(|sym| *sym);
        let vsl_encoder_new_output_frame = __library
            .get(b"vsl_encoder_new_output_frame\0")
            .map(|sym| *sym);
        let vsl_camera_open_device = __library.get(b"vsl_camera_open_device\0").map(|sym| *sym);
        let vsl_camera_init_device = __library.get(b"vsl_camera_init_device\0").map(|sym| *sym);
        let vsl_camera_mirror = __library.get(b"vsl_camera_mirror\0").map(|sym| *sym);
        let vsl_camera_mirror_v = __library.get(b"vsl_camera_mirror_v\0").map(|sym| *sym);
        let vsl_camera_start_capturing = __library
            .get(b"vsl_camera_start_capturing\0")
            .map(|sym| *sym);
        let vsl_camera_get_data = __library.get(b"vsl_camera_get_data\0").map(|sym| *sym);
        let vsl_camera_release_buffer = __library
            .get(b"vsl_camera_release_buffer\0")
            .map(|sym| *sym);
        let vsl_camera_stop_capturing = __library
            .get(b"vsl_camera_stop_capturing\0")
            .map(|sym| *sym);
        let vsl_camera_uninit_device = __library.get(b"vsl_camera_uninit_device\0").map(|sym| *sym);
        let vsl_camera_close_device = __library.get(b"vsl_camera_close_device\0").map(|sym| *sym);
        let vsl_camera_is_dmabuf_supported = __library
            .get(b"vsl_camera_is_dmabuf_supported\0")
            .map(|sym| *sym);
        let vsl_camera_get_queued_buf_count = __library
            .get(b"vsl_camera_get_queued_buf_count\0")
            .map(|sym| *sym);
        let vsl_camera_buffer_mmap = __library.get(b"vsl_camera_buffer_mmap\0").map(|sym| *sym);
        let vsl_camera_buffer_dma_fd = __library.get(b"vsl_camera_buffer_dma_fd\0").map(|sym| *sym);
        let vsl_camera_buffer_phys_addr = __library
            .get(b"vsl_camera_buffer_phys_addr\0")
            .map(|sym| *sym);
        let vsl_camera_buffer_length = __library.get(b"vsl_camera_buffer_length\0").map(|sym| *sym);
        let vsl_camera_buffer_fourcc = __library.get(b"vsl_camera_buffer_fourcc\0").map(|sym| *sym);
        let vsl_camera_buffer_timestamp = __library
            .get(b"vsl_camera_buffer_timestamp\0")
            .map(|sym| *sym);
        let vsl_camera_enum_fmts = __library.get(b"vsl_camera_enum_fmts\0").map(|sym| *sym);
        let vsl_camera_enum_mplane_fmts = __library
            .get(b"vsl_camera_enum_mplane_fmts\0")
            .map(|sym| *sym);
        let vsl_decoder_create = __library.get(b"vsl_decoder_create\0").map(|sym| *sym);
        let vsl_decoder_create_ex = __library.get(b"vsl_decoder_create_ex\0").map(|sym| *sym);
        let vsl_decode_frame = __library.get(b"vsl_decode_frame\0").map(|sym| *sym);
        let vsl_decoder_width = __library.get(b"vsl_decoder_width\0").map(|sym| *sym);
        let vsl_decoder_height = __library.get(b"vsl_decoder_height\0").map(|sym| *sym);
        let vsl_decoder_crop = __library.get(b"vsl_decoder_crop\0").map(|sym| *sym);
        let vsl_decoder_release = __library.get(b"vsl_decoder_release\0").map(|sym| *sym);
        Ok(VideoStreamLibrary {
            __library,
            vsl_version,
            vsl_timestamp,
            vsl_host_init,
            vsl_host_release,
            vsl_host_path,
            vsl_host_poll,
            vsl_host_service,
            vsl_host_process,
            vsl_host_sockets,
            vsl_host_post,
            vsl_host_drop,
            vsl_client_init,
            vsl_client_release,
            vsl_client_disconnect,
            vsl_client_userptr,
            vsl_client_path,
            vsl_client_set_timeout,
            vsl_frame_register,
            vsl_frame_init,
            vsl_frame_alloc,
            vsl_frame_unalloc,
            vsl_frame_attach,
            vsl_frame_path,
            vsl_frame_unregister,
            vsl_frame_copy,
            vsl_frame_userptr,
            vsl_frame_set_userptr,
            vsl_frame_wait,
            vsl_frame_release,
            vsl_frame_trylock,
            vsl_frame_unlock,
            vsl_frame_serial,
            vsl_frame_timestamp,
            vsl_frame_duration,
            vsl_frame_pts,
            vsl_frame_dts,
            vsl_frame_expires,
            vsl_frame_fourcc,
            vsl_frame_width,
            vsl_frame_height,
            vsl_frame_stride,
            vsl_frame_size,
            vsl_frame_handle,
            vsl_frame_paddr,
            vsl_frame_mmap,
            vsl_frame_munmap,
            vsl_frame_sync,
            vsl_fourcc_from_string,
            vsl_encoder_create,
            vsl_encoder_create_ex,
            vsl_encoder_release,
            vsl_encode_frame,
            vsl_encoder_new_output_frame,
            vsl_camera_open_device,
            vsl_camera_init_device,
            vsl_camera_mirror,
            vsl_camera_mirror_v,
            vsl_camera_start_capturing,
            vsl_camera_get_data,
            vsl_camera_release_buffer,
            vsl_camera_stop_capturing,
            vsl_camera_uninit_device,
            vsl_camera_close_device,
            vsl_camera_is_dmabuf_supported,
            vsl_camera_get_queued_buf_count,
            vsl_camera_buffer_mmap,
            vsl_camera_buffer_dma_fd,
            vsl_camera_buffer_phys_addr,
            vsl_camera_buffer_length,
            vsl_camera_buffer_fourcc,
            vsl_camera_buffer_timestamp,
            vsl_camera_enum_fmts,
            vsl_camera_enum_mplane_fmts,
            vsl_decoder_create,
            vsl_decoder_create_ex,
            vsl_decode_frame,
            vsl_decoder_width,
            vsl_decoder_height,
            vsl_decoder_crop,
            vsl_decoder_release,
        })
    }
    #[doc = " Returns the VideoStream Library version string.\n\n @return Version string in \"MAJOR.MINOR.PATCH\" format (e.g., \"1.5.4\")\n @since 1.0"]
    pub unsafe fn vsl_version(&self) -> *const ::std::os::raw::c_char {
        (self
            .vsl_version
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Returns the current timestamp in nanoseconds.\n\n Uses monotonic clock (CLOCK_MONOTONIC) for consistent timing across the\n system. This timestamp is used for frame timing and synchronization.\n\n @return Current time in nanoseconds since an unspecified starting point\n @since 1.0"]
    pub unsafe fn vsl_timestamp(&self) -> i64 {
        (self
            .vsl_timestamp
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Creates a host on the requested path for inter-process frame sharing.\n\n The host manages a UNIX domain socket at the specified path and accepts\n connections from clients. Frames posted to the host are broadcast to all\n connected clients.\n\n @param path UNIX socket path (filesystem or abstract). If path starts with\n             '/' it creates a filesystem socket, otherwise an abstract socket.\n @return Pointer to VSLHost object on success, NULL on failure (sets errno)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_init(&self, path: *const ::std::os::raw::c_char) -> *mut VSLHost {
        (self
            .vsl_host_init
            .as_ref()
            .expect("Expected function, got error."))(path)
    }
    #[doc = " Releases the host, disconnecting all clients and releasing any allocated\n memory.\n\n Closes the UNIX socket, disconnects all clients, and frees all resources\n associated with the host. Any posted frames are released.\n\n @param host The host to release\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_release(&self, host: *mut VSLHost) {
        (self
            .vsl_host_release
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Returns the bound path of the host.\n\n @param host The host instance\n @return UNIX socket path string (owned by host, do not free)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_path(&self, host: *const VSLHost) -> *const ::std::os::raw::c_char {
        (self
            .vsl_host_path
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Polls the list of available connections for activity.\n\n Waits for socket activity (new connections or client messages) using poll().\n Should be called in a loop before vsl_host_process(). Note frames are only\n expired by vsl_host_process(), so the wait parameter should be no greater\n than the desired frame expiration time to ensure timely cleanup.\n\n @param host The host instance\n @param wait Timeout in milliseconds. If >0, poll waits up to this duration.\n             If 0, returns immediately. If <0, waits indefinitely.\n @return Number of sockets with activity, 0 on timeout, -1 on error (sets\n errno)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_poll(&self, host: *mut VSLHost, wait: i64) -> ::std::os::raw::c_int {
        (self
            .vsl_host_poll
            .as_ref()
            .expect("Expected function, got error."))(host, wait)
    }
    #[doc = " Services a single client socket.\n\n Processes messages from a specific client socket. Does not accept new\n connections - use vsl_host_process() for that. Useful when you need to\n track errors for individual clients.\n\n @param host The host instance\n @param sock The client socket file descriptor to service\n @return 0 on success, -1 on error (sets errno, EPIPE if client disconnected)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_service(
        &self,
        host: *mut VSLHost,
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_service
            .as_ref()
            .expect("Expected function, got error."))(host, sock)
    }
    #[doc = " Process host tasks: expire old frames and service one client connection.\n\n First expires frames past their lifetime, then services the first available\n connection (accepting new clients or processing client messages). Should be\n called in a loop, typically after vsl_host_poll() indicates activity.\n\n @param host The host instance\n @return 0 on success, -1 on error (sets errno, ETIMEDOUT if no activity)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_process(&self, host: *mut VSLHost) -> ::std::os::raw::c_int {
        (self
            .vsl_host_process
            .as_ref()
            .expect("Expected function, got error."))(host)
    }
    #[doc = " Request a copy of the sockets managed by the host.\n\n Returns socket file descriptors for the host's listening socket and all\n connected client sockets. The first socket is always the listening socket.\n The array should be refreshed frequently as sockets may become stale.\n\n Thread-safe: allows one thread to use sockets for messaging while another\n polls for reads.\n\n @param host The host instance\n @param n_sockets Size of the sockets array buffer\n @param sockets Buffer to receive socket file descriptors\n @param max_sockets If provided, populated with n_clients+1 (total sockets)\n @return 0 on success, -1 on error (sets errno to ENOBUFS if buffer too small)\n @since 1.0\n @memberof VSLHost"]
    pub unsafe fn vsl_host_sockets(
        &self,
        host: *mut VSLHost,
        n_sockets: usize,
        sockets: *mut ::std::os::raw::c_int,
        max_sockets: *mut usize,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_sockets
            .as_ref()
            .expect("Expected function, got error."))(host, n_sockets, sockets, max_sockets)
    }
    #[doc = " Registers the frame with the host and publishes it to subscribers.\n\n Transfers ownership of the frame to the host. The frame is broadcast to all\n connected clients and will be automatically released when it expires. Do not\n call vsl_frame_release() on frames posted to the host.\n\n @param host The host instance\n @param frame Frame to post (ownership transferred to host)\n @param expires Expiration time in nanoseconds (absolute, from\n vsl_timestamp())\n @param duration Frame duration in nanoseconds (-1 if unknown)\n @param pts Presentation timestamp in nanoseconds (-1 if unknown)\n @param dts Decode timestamp in nanoseconds (-1 if unknown)\n @return 0 on success, -1 on error (sets errno)\n @since 1.3\n @memberof VSLHost"]
    pub unsafe fn vsl_host_post(
        &self,
        host: *mut VSLHost,
        frame: *mut VSLFrame,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_post
            .as_ref()
            .expect("Expected function, got error."))(
            host, frame, expires, duration, pts, dts
        )
    }
    #[doc = " Drops the frame from the host.\n\n Removes the host association of the frame and returns ownership to the\n caller. Can be used to cancel a previously posted frame before it expires.\n\n @param host The host instance\n @param frame Frame to drop from host\n @return 0 on success, -1 on error (sets errno)\n @since 1.3\n @memberof VSLHost"]
    pub unsafe fn vsl_host_drop(
        &self,
        host: *mut VSLHost,
        frame: *mut VSLFrame,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_host_drop
            .as_ref()
            .expect("Expected function, got error."))(host, frame)
    }
    #[doc = " Creates a client and connects to the host at the provided path.\n\n Establishes a connection to a VSLHost via UNIX domain socket. The client\n can receive frames broadcast by the host.\n\n @param path UNIX socket path matching the host's path\n @param userptr Optional user data pointer (retrievable via\n vsl_client_userptr)\n @param reconnect If true, automatically reconnect if connection is lost\n @return Pointer to VSLClient object on success, NULL on failure (sets errno)\n @since 1.0\n @memberof VSLClient"]
    pub unsafe fn vsl_client_init(
        &self,
        path: *const ::std::os::raw::c_char,
        userptr: *mut ::std::os::raw::c_void,
        reconnect: bool,
    ) -> *mut VSLClient {
        (self
            .vsl_client_init
            .as_ref()
            .expect("Expected function, got error."))(path, userptr, reconnect)
    }
    #[doc = " Releases the client, disconnecting from the host and releasing allocated\n memory.\n\n Closes the socket connection, frees all resources, and invalidates any\n pending frames. Not thread-safe - use vsl_client_disconnect() for\n thread-safe disconnection before calling this.\n\n @param client The client to release\n @since 1.0\n @memberof VSLClient"]
    pub unsafe fn vsl_client_release(&self, client: *mut VSLClient) {
        (self
            .vsl_client_release
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Disconnects from the VSLHost and stops all reconnection attempts.\n\n Thread-safe disconnect operation. Should be called before\n vsl_client_release() when shutting down a client session from a different\n thread.\n\n @param client The client to disconnect\n @since 1.1\n @memberof VSLClient"]
    pub unsafe fn vsl_client_disconnect(&self, client: *mut VSLClient) {
        (self
            .vsl_client_disconnect
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Returns the optional userptr associated with this client connection.\n\n @param client The client instance\n @return User pointer provided to vsl_client_init(), or NULL if none\n @since 1.0\n @memberof VSLClient"]
    pub unsafe fn vsl_client_userptr(&self, client: *mut VSLClient) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_client_userptr
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Returns the path on which the client has connected to the host.\n\n @param client The client instance\n @return UNIX socket path string (owned by client, do not free)\n @since 1.0\n @memberof VSLClient"]
    pub unsafe fn vsl_client_path(
        &self,
        client: *const VSLClient,
    ) -> *const ::std::os::raw::c_char {
        (self
            .vsl_client_path
            .as_ref()
            .expect("Expected function, got error."))(client)
    }
    #[doc = " Sets the socket timeout for this client.\n\n Configures how long socket operations wait before timing out. Affects\n recv() calls when waiting for frames from the host.\n\n @param client The client instance\n @param timeout Timeout in seconds (e.g., 1.0 for 1 second)\n @since 1.0\n @memberof VSLClient"]
    pub unsafe fn vsl_client_set_timeout(&self, client: *mut VSLClient, timeout: f32) {
        (self
            .vsl_client_set_timeout
            .as_ref()
            .expect("Expected function, got error."))(client, timeout)
    }
    #[doc = " Creates and posts the video frame along with optional user pointer to any\n arbitrary data.  Typically it would be used for holding a reference to\n the host's view of the frame handle.\n\n @deprecated The vsl_frame_register function is deprecated in favour of using\n the @ref vsl_frame_init(), @ref vsl_frame_alloc() or @ref vsl_frame_attach(),\n and @ref vsl_host_post() functions which separate frame creation from posting\n to the host for publishing to subscribers.\n\n @note A frame created through this function is owned by the host and should\n not have @ref vsl_frame_release called on it.  This will be managed by the\n host on frame expiry.\n\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_register(
        &self,
        host: *mut VSLHost,
        serial: i64,
        handle: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fourcc: u32,
        size: usize,
        offset: usize,
        expires: i64,
        duration: i64,
        pts: i64,
        dts: i64,
        cleanup: vsl_frame_cleanup,
        userptr: *mut ::std::os::raw::c_void,
    ) -> *mut VSLFrame {
        (self
            .vsl_frame_register
            .as_ref()
            .expect("Expected function, got error."))(
            host, serial, handle, width, height, fourcc, size, offset, expires, duration, pts, dts,
            cleanup, userptr,
        )
    }
    #[doc = " Initializes a VSLFrame without underlying frame buffer.\n\n Creates a frame descriptor with specified dimensions and format. To allocate\n backing memory, call vsl_frame_alloc(). To attach existing memory (e.g.,\n DmaBuf from camera), call vsl_frame_attach().\n\n @param width Frame width in pixels\n @param height Frame height in pixels\n @param stride Row stride in bytes (0 to auto-calculate from width)\n @param fourcc Pixel format as FOURCC code (e.g., VSL_FOURCC('N','V','1','2'))\n @param userptr Optional user data pointer\n @param cleanup Optional cleanup callback invoked on vsl_frame_release()\n @return Pointer to VSLFrame object, or NULL on failure\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_init(
        &self,
        width: u32,
        height: u32,
        stride: u32,
        fourcc: u32,
        userptr: *mut ::std::os::raw::c_void,
        cleanup: vsl_frame_cleanup,
    ) -> *mut VSLFrame {
        (self
            .vsl_frame_init
            .as_ref()
            .expect("Expected function, got error."))(
            width, height, stride, fourcc, userptr, cleanup,
        )
    }
    #[doc = " Allocates the underlying memory for the frame.\n\n Prefers DmaBuf allocation for zero-copy, falling back to POSIX shared memory\n if DmaBuf unavailable. If path is provided, it determines allocation type:\n - NULL: Try DmaBuf first, fallback to shared memory\n - Starts with \"/dev\": Use DmaBuf heap device at this path\n - Other paths: Use shared memory at this path\n\n Allocates height*stride bytes. For compressed formats (JPEG, H.264), the\n actual data size may be smaller. Use vsl_frame_copy() return value to get\n actual compressed size.\n\n @param frame Frame to allocate memory for\n @param path Optional allocation path (NULL for auto, /dev/... for DmaBuf\n heap)\n @return 0 on success, -1 on failure (sets errno)\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_alloc(
        &self,
        frame: *mut VSLFrame,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_alloc
            .as_ref()
            .expect("Expected function, got error."))(frame, path)
    }
    #[doc = " Frees the allocated buffer for this frame.\n\n Releases the underlying memory (DmaBuf or shared memory) but does not\n destroy the frame object. Use vsl_frame_release() to destroy the frame.\n\n @param frame Frame whose buffer should be freed\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unalloc(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_unalloc
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attach the provided file descriptor to the VSLFrame.\n\n Associates an existing buffer (typically DmaBuf from camera or hardware\n accelerator) with the frame. The frame does not take ownership of the FD.\n\n @param frame Frame to attach buffer to\n @param fd File descriptor (typically DmaBuf) to attach\n @param size Buffer size in bytes (0 to use stride*height)\n @param offset Byte offset to frame data start (must provide size if offset>0)\n @return 0 on success, -1 on failure (sets errno)\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_attach(
        &self,
        frame: *mut VSLFrame,
        fd: ::std::os::raw::c_int,
        size: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_attach
            .as_ref()
            .expect("Expected function, got error."))(frame, fd, size, offset)
    }
    #[doc = " Returns the path to the underlying VSLFrame buffer.\n\n Returns the filesystem path for shared memory buffers or DmaBuf heap devices.\n Not available for externally created DmaBufs (e.g., from camera driver).\n\n @warning Not thread-safe. Use the returned string immediately.\n\n @param frame The frame instance\n @return Buffer path string (owned by frame), or NULL if unavailable\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_path(&self, frame: *const VSLFrame) -> *const ::std::os::raw::c_char {
        (self
            .vsl_frame_path
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Unregisters the frame, removing it from the host pool.\n\n @deprecated Use vsl_frame_release() instead, which handles cleanup properly.\n\n @param frame Frame to unregister\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unregister(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_unregister
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Copy the source frame into the target frame, with optional source crop.\n\n Handles format conversion, rescaling, and cropping using hardware\n acceleration when available (G2D on i.MX8). Both frames can be host or client\n frames. Automatically locks frames during copy (safe for free-standing frames\n too).\n\n Copy sequence: 1) Crop source, 2) Convert format, 3) Scale to target size.\n\n @warning Copying to/from a posted frame may cause visual tearing.\n\n @param target Destination frame (receives copied data)\n @param source Source frame to copy from\n @param crop Optional crop region in source coordinates (NULL for full frame)\n @return Number of bytes copied on success, -1 on failure (sets errno)\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_copy(
        &self,
        target: *mut VSLFrame,
        source: *mut VSLFrame,
        crop: *const VSLRect,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_copy
            .as_ref()
            .expect("Expected function, got error."))(target, source, crop)
    }
    #[doc = " Returns the user pointer associated with this frame.\n\n @param frame The frame instance\n @return User pointer provided to vsl_frame_init(), or NULL if none\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_userptr(&self, frame: *mut VSLFrame) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_frame_userptr
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Associate userptr with this frame.\n\n Sets or updates the user data pointer for this frame.\n\n @param frame The frame instance\n @param userptr User data pointer to associate with frame\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_set_userptr(
        &self,
        frame: *mut VSLFrame,
        userptr: *mut ::std::os::raw::c_void,
    ) {
        (self
            .vsl_frame_set_userptr
            .as_ref()
            .expect("Expected function, got error."))(frame, userptr)
    }
    #[doc = " Waits for a frame to arrive and returns a new frame object.\n\n Blocks until the host broadcasts a new frame. Frames with timestamp less\n than 'until' are ignored (useful for skipping old frames after a pause).\n\n Caller must lock the frame (vsl_frame_trylock) before accessing data,\n then unlock and release when done.\n\n @param client The client instance\n @param until Minimum timestamp in nanoseconds (0 to accept next frame)\n @return Pointer to VSLFrame object, or NULL on error (sets errno)\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_wait(&self, client: *mut VSLClient, until: i64) -> *mut VSLFrame {
        (self
            .vsl_frame_wait
            .as_ref()
            .expect("Expected function, got error."))(client, until)
    }
    #[doc = " Releases the frame, performing required cleanup.\n\n Unmaps memory if mapped, unlocks if locked. If frame was posted to a host,\n removes it. If client frame, decrements reference count. Invokes cleanup\n callback if registered.\n\n @param frame Frame to release\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_release(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_release
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attempts to lock the video frame.\n\n Locks the frame for exclusive access (prevents host from releasing it).\n Must be called before accessing frame data from a client. Always succeeds\n for host-owned frames.\n\n @param frame Frame to lock\n @return 0 on success, -1 on failure (frame expired or already unlocked)\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_trylock(&self, frame: *mut VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_trylock
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Attempts to unlock the video frame.\n\n Releases the lock acquired by vsl_frame_trylock(), allowing the host to\n release the frame when it expires.\n\n @param frame Frame to unlock\n @return 0 on success, -1 on failure (sets errno)\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_unlock(&self, frame: *mut VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_unlock
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the serial frame count of the video frame.\n\n Frame serial is a monotonically increasing counter assigned by the host\n when frames are registered. Does not necessarily equal camera frame number.\n\n @param frame The frame instance\n @return Frame serial number (starts at 1)\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_serial(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_serial
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the timestamp for this frame in nanoseconds.\n\n Timestamp from vsl_timestamp() when frame was registered with host.\n Uses monotonic clock for consistent timing.\n\n @param frame The frame instance\n @return Frame timestamp in nanoseconds\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_timestamp(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_timestamp
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the duration for this frame in nanoseconds.\n\n Frame duration indicates how long this frame should be displayed.\n May be -1 if unknown or not applicable.\n\n @param frame The frame instance\n @return Frame duration in nanoseconds, or -1 if unknown\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_duration(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_duration
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the presentation timestamp for this frame in nanoseconds.\n\n PTS indicates when this frame should be presented/displayed in a stream.\n May be -1 if unknown or not applicable.\n\n @param frame The frame instance\n @return Presentation timestamp in nanoseconds, or -1 if unknown\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_pts(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_pts
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the decode timestamp for this frame in nanoseconds.\n\n DTS indicates when this frame should be decoded in a stream (important for\n B-frames in video codecs). May be -1 if unknown or not applicable.\n\n @param frame The frame instance\n @return Decode timestamp in nanoseconds, or -1 if unknown\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_dts(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_dts
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the expiration time for this frame in nanoseconds.\n\n Absolute timestamp (from vsl_timestamp()) when this frame will be expired\n by the host. Clients should lock frames before this time.\n\n @param frame The frame instance\n @return Expiration timestamp in nanoseconds\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_expires(&self, frame: *const VSLFrame) -> i64 {
        (self
            .vsl_frame_expires
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the FOURCC code for the video frame.\n\n FOURCC identifies the pixel format (e.g., NV12, YUY2, JPEG, H264).\n Use VSL_FOURCC() macro to create fourcc codes.\n\n @param frame The frame instance\n @return FOURCC code as uint32_t\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_fourcc(&self, frame: *const VSLFrame) -> u32 {
        (self
            .vsl_frame_fourcc
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the width in pixels of the video frame.\n\n @param frame The frame instance\n @return Frame width in pixels\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_width(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_width
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the height in pixels of the video frame.\n\n @param frame The frame instance\n @return Frame height in pixels\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_height(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_height
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the stride in bytes of the video frame.\n\n Stride is the number of bytes from the start of one row to the next.\n May be larger than width*bytes_per_pixel due to alignment requirements.\n\n @param frame The frame instance\n @return Row stride in bytes\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_stride(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_stride
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the size in bytes of the video frame buffer.\n\n For uncompressed formats, this is stride*height. For compressed formats\n (JPEG, H.264), this is the maximum buffer size, not the actual data size.\n\n @param frame The frame instance\n @return Buffer size in bytes\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_size(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_size
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the file descriptor for this frame.\n\n Returns the DmaBuf or shared memory file descriptor used for zero-copy\n sharing. Returns -1 if no file descriptor is associated (e.g., CPU-only\n memory).\n\n @param frame The frame instance\n @return File descriptor, or -1 if none\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_handle(&self, frame: *const VSLFrame) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_handle
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Returns the physical address of the frame.\n\n Physical address is available for DMA-capable buffers on platforms where\n the kernel provides physical address translation (some i.MX platforms).\n\n @param frame The frame instance\n @return Physical address, or MMAP_FAILED ((intptr_t)-1) if DMA not supported\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_paddr(&self, frame: *const VSLFrame) -> isize {
        (self
            .vsl_frame_paddr
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Maps the frame into the process memory space.\n\n Creates a memory mapping for CPU access to frame data. Frame must be locked\n (vsl_frame_trylock) for the duration of the mapping. Call vsl_frame_munmap()\n when done.\n\n @param frame The frame instance\n @param size Optional pointer to receive mapped size in bytes (may be NULL)\n @return Pointer to mapped memory, or NULL on failure\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_mmap(
        &self,
        frame: *mut VSLFrame,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_frame_mmap
            .as_ref()
            .expect("Expected function, got error."))(frame, size)
    }
    #[doc = " Unmaps the frame from the process memory space.\n\n Releases the memory mapping created by vsl_frame_mmap(). Should be called\n when done accessing frame data.\n\n @param frame The frame instance to unmap\n @since 1.0\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_munmap(&self, frame: *mut VSLFrame) {
        (self
            .vsl_frame_munmap
            .as_ref()
            .expect("Expected function, got error."))(frame)
    }
    #[doc = " Cache synchronization session control for DMA-backed buffers.\n\n Controls CPU cache coherency for DMA buffers. Automatically called by\n mmap/munmap, but can be used manually for in-place frame updates.\n\n Call with enable=1 before accessing, enable=0 after modifying.\n Mode: DMA_BUF_SYNC_READ (CPU reads), DMA_BUF_SYNC_WRITE (CPU writes),\n       or DMA_BUF_SYNC_RW (both).\n\n @param frame The frame object to synchronize\n @param enable 1 to start sync session, 0 to end it\n @param mode Sync mode: DMA_BUF_SYNC_READ, DMA_BUF_SYNC_WRITE, or\n DMA_BUF_SYNC_RW\n @return 0 on success, -1 on failure (sets errno)\n @since 1.3\n @memberof VSLFrame"]
    pub unsafe fn vsl_frame_sync(
        &self,
        frame: *const VSLFrame,
        enable: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_frame_sync
            .as_ref()
            .expect("Expected function, got error."))(frame, enable, mode)
    }
    #[doc = " Returns a fourcc integer code from the string.\n\n Converts a 4-character string to FOURCC code. Example: \"NV12\" ->\n VSL_FOURCC('N','V','1','2').\n\n @param fourcc String containing exactly 4 characters (e.g., \"NV12\", \"YUY2\")\n @return FOURCC code as uint32_t, or 0 if invalid/unsupported\n @since 1.3"]
    pub unsafe fn vsl_fourcc_from_string(&self, fourcc: *const ::std::os::raw::c_char) -> u32 {
        (self
            .vsl_fourcc_from_string
            .as_ref()
            .expect("Expected function, got error."))(fourcc)
    }
    #[doc = " @brief Creates VSLEncoder instance\n\n @param profile VSLEncoderProfile determining encode quality\n @param outputFourcc fourcc code defining the codec\n @param fps output stream fps\n @return VSLEncoder* new encoder instance\n\n Every encoder instance must be released using vsl_encoder_release\n\n For Hantro VC8000e encoder initialization is performed when vsl_encode_frame\n is called for a first time"]
    pub unsafe fn vsl_encoder_create(
        &self,
        profile: VSLEncoderProfile,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
    ) -> *mut VSLEncoder {
        (self
            .vsl_encoder_create
            .as_ref()
            .expect("Expected function, got error."))(profile, outputFourcc, fps)
    }
    #[doc = " @brief Creates VSLEncoder instance with explicit backend selection\n\n Extended version of vsl_encoder_create() that allows selecting a specific\n codec backend. Use this when you need to force V4L2 or Hantro backend.\n\n @param profile VSLEncoderProfile determining encode quality\n @param outputFourcc fourcc code defining the codec (H264 or HEVC)\n @param fps output stream fps\n @param backend Which backend to use (VSL_CODEC_BACKEND_AUTO, _V4L2, _HANTRO)\n @return VSLEncoder* new encoder instance, or NULL if backend unavailable\n\n @since 2.0"]
    pub unsafe fn vsl_encoder_create_ex(
        &self,
        profile: VSLEncoderProfile,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
        backend: VSLCodecBackend,
    ) -> *mut VSLEncoder {
        (self
            .vsl_encoder_create_ex
            .as_ref()
            .expect("Expected function, got error."))(profile, outputFourcc, fps, backend)
    }
    #[doc = " @brief Destroys VSLEncoder instance\n\n Frees all resources associated with the encoder, including hardware\n resources. Do not use the encoder after calling this function.\n\n @param encoder VSLEncoder instance to destroy\n @since 1.3"]
    pub unsafe fn vsl_encoder_release(&self, encoder: *mut VSLEncoder) {
        (self
            .vsl_encoder_release
            .as_ref()
            .expect("Expected function, got error."))(encoder)
    }
    #[doc = " @brief Encode frame\n\n Encodes the source frame into the destination frame using hardware\n acceleration (Hantro VPU on i.MX8). First call initializes the encoder with\n the given parameters. Subsequent calls must use identical source/destination\n dimensions, formats, and crop region.\n\n @param encoder VSLEncoder instance\n @param source Source frame (raw video data)\n @param destination Pre-allocated destination frame (receives encoded data)\n @param cropRegion Optional crop region in source coordinates (NULL for no\n crop)\n @param keyframe Optional output: set to 1 if encoded frame is IDR/keyframe,\n                 0 otherwise. Pass NULL to ignore.\n @retval 0 on success\n @retval -1 on failure (check errno for details)\n @since 1.3"]
    pub unsafe fn vsl_encode_frame(
        &self,
        encoder: *mut VSLEncoder,
        source: *mut VSLFrame,
        destination: *mut VSLFrame,
        cropRegion: *const VSLRect,
        keyframe: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_encode_frame
            .as_ref()
            .expect("Expected function, got error."))(
            encoder,
            source,
            destination,
            cropRegion,
            keyframe,
        )
    }
    #[doc = " @brief Creates a new output frame for encoder\n\n Allocates a frame suitable for receiving encoded output from\n vsl_encode_frame(). The frame uses encoder-specific memory (e.g., Hantro VPU\n EWL memory on i.MX8) for efficient hardware encoding.\n\n @param encoder VSLEncoder instance\n @param width Encoded frame width in pixels (should match encoder source)\n @param height Encoded frame height in pixels (should match encoder source)\n @param duration Frame duration in nanoseconds (passed through to output)\n @param pts Presentation timestamp in nanoseconds (passed through to output)\n @param dts Decode timestamp in nanoseconds (passed through to output)\n @return Pointer to VSLFrame for encoded output, or NULL on failure\n @since 1.3"]
    pub unsafe fn vsl_encoder_new_output_frame(
        &self,
        encoder: *const VSLEncoder,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> *mut VSLFrame {
        (self
            .vsl_encoder_new_output_frame
            .as_ref()
            .expect("Expected function, got error."))(
            encoder, width, height, duration, pts, dts
        )
    }
    #[doc = " Opens the camera device specified by filename and allocates device memory.\n\n Opens a V4L2 video capture device (e.g., /dev/video0) and prepares it for\n streaming. The device is not yet configured - call vsl_camera_init_device()\n next.\n\n @param filename V4L2 device path (e.g., \"/dev/video0\")\n @return Pointer to vsl_camera context on success, NULL on failure\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_open_device(
        &self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut vsl_camera {
        (self
            .vsl_camera_open_device
            .as_ref()
            .expect("Expected function, got error."))(filename)
    }
    #[doc = " Initializes the camera device for streaming and allocates camera buffers.\n\n Negotiates format with the V4L2 driver. On entry, width/height/fourcc contain\n desired values (0 for driver default). On success, they're updated with\n actual negotiated values. Allocates buf_count buffers (updated with actual\n count).\n\n Must be called after vsl_camera_open_device() and before\n vsl_camera_start_capturing().\n\n @param ctx Camera context from vsl_camera_open_device()\n @param width Pointer to desired/actual width in pixels (0 for default)\n @param height Pointer to desired/actual height in pixels (0 for default)\n @param buf_count Pointer to desired/actual buffer count (0 for default)\n @param fourcc Pointer to desired/actual fourcc format (0 for default)\n @return 0 on success, -1 on error\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_init_device(
        &self,
        ctx: *mut vsl_camera,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        buf_count: *mut ::std::os::raw::c_int,
        fourcc: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_init_device
            .as_ref()
            .expect("Expected function, got error."))(ctx, width, height, buf_count, fourcc)
    }
    #[doc = " Requests the camera to mirror the image left-to-right.\n\n Uses V4L2_CID_HFLIP control to flip the image horizontally.\n Not all cameras support this feature.\n\n @param ctx Camera context\n @param mirror true to enable horizontal flip, false to disable\n @return 0 on success, -1 if driver refused the request\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_mirror(
        &self,
        ctx: *const vsl_camera,
        mirror: bool,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_mirror
            .as_ref()
            .expect("Expected function, got error."))(ctx, mirror)
    }
    #[doc = " Requests the camera to mirror the image top-to-bottom.\n\n Uses V4L2_CID_VFLIP control to flip the image vertically.\n Not all cameras support this feature.\n\n @param ctx Camera context\n @param mirror true to enable vertical flip, false to disable\n @return 0 on success, -1 if driver refused the request\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_mirror_v(
        &self,
        ctx: *const vsl_camera,
        mirror: bool,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_mirror_v
            .as_ref()
            .expect("Expected function, got error."))(ctx, mirror)
    }
    #[doc = " Starts the camera stream.\n\n Begins V4L2 streaming (VIDIOC_STREAMON). Frames can now be captured with\n vsl_camera_get_data(). Must be called after vsl_camera_init_device().\n\n @param ctx Camera context\n @return 0 on success, -1 on error\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_start_capturing(&self, ctx: *mut vsl_camera) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_start_capturing
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Attempts to read a frame from the camera.\n\n Dequeues a filled buffer from the camera driver (VIDIOC_DQBUF). Blocks until\n a frame is available. Must be called after vsl_camera_start_capturing().\n\n After processing, call vsl_camera_release_buffer() to return the buffer to\n the driver's queue for reuse.\n\n @param ctx Camera context\n @return Pointer to camera buffer, or NULL on timeout/error\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_get_data(&self, ctx: *mut vsl_camera) -> *mut vsl_camera_buffer {
        (self
            .vsl_camera_get_data
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Enqueues a buffer to be reused for frame capture.\n\n Returns the buffer to the camera driver's queue (VIDIOC_QBUF) so it can be\n filled with new frame data. Must be called after processing each buffer from\n vsl_camera_get_data().\n\n @param ctx Camera context\n @param buffer Buffer to release (from vsl_camera_get_data)\n @return 0 on success, -1 on error\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_release_buffer(
        &self,
        ctx: *mut vsl_camera,
        buffer: *const vsl_camera_buffer,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_release_buffer
            .as_ref()
            .expect("Expected function, got error."))(ctx, buffer)
    }
    #[doc = " Stops the camera stream.\n\n Stops V4L2 streaming (VIDIOC_STREAMOFF). No more frames will be captured.\n Call before vsl_camera_uninit_device() and vsl_camera_close_device().\n\n @param ctx Camera context\n @return 0 on success, -1 on error\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_stop_capturing(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_stop_capturing
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Uninitializes the camera buffers and frees the buffer memory.\n\n Releases all allocated camera buffers. Ensure the device is not streaming\n (call vsl_camera_stop_capturing() first).\n\n @param ctx Camera context\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_uninit_device(&self, ctx: *mut vsl_camera) {
        (self
            .vsl_camera_uninit_device
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Closes the camera device and frees the device memory.\n\n Closes the V4L2 device file descriptor and releases all resources.\n Ensure the device is not streaming (call vsl_camera_stop_capturing() and\n vsl_camera_uninit_device() first).\n\n @param ctx Camera context to close\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_close_device(&self, ctx: *mut vsl_camera) {
        (self
            .vsl_camera_close_device
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Checks if DmaBuf export is supported on the camera.\n\n DmaBuf support allows zero-copy frame sharing with hardware accelerators\n (VPU, NPU, GPU). Requires V4L2 driver support for VIDIOC_EXPBUF.\n\n Must be called after vsl_camera_init_device().\n\n @param ctx Camera context\n @return 1 if DmaBuf supported, 0 if not supported\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_is_dmabuf_supported(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_is_dmabuf_supported
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Returns the number of buffers queued in the camera driver.\n\n Queued buffers are available for the driver to fill with new frames.\n If count reaches 0, vsl_camera_get_data() will block/timeout waiting for\n buffers to be released via vsl_camera_release_buffer().\n\n @param ctx Camera context\n @return Number of queued buffers\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_get_queued_buf_count(
        &self,
        ctx: *const vsl_camera,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_get_queued_buf_count
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    #[doc = " Returns the mmap memory pointer of the camera buffer.\n\n Provides CPU access to the camera buffer's memory. The buffer is already\n mapped by the camera driver.\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @return Pointer to mapped memory\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_mmap(
        &self,
        buffer: *mut vsl_camera_buffer,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .vsl_camera_buffer_mmap
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the DmaBuf file descriptor of the camera buffer.\n\n Returns the DmaBuf FD for zero-copy sharing with hardware accelerators.\n Only available if vsl_camera_is_dmabuf_supported() returns true.\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @return DmaBuf file descriptor, or -1 if DmaBuf not supported\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_dma_fd(
        &self,
        buffer: *const vsl_camera_buffer,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_buffer_dma_fd
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the physical address of the camera buffer.\n\n Physical address is available on some platforms (certain i.MX drivers) for\n DMA operations. Not commonly used - prefer DmaBuf FD for portability.\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @return Physical address, or 0 if not supported\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_phys_addr(&self, buffer: *const vsl_camera_buffer) -> u64 {
        (self
            .vsl_camera_buffer_phys_addr
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the length of the camera buffer in bytes.\n\n Buffer size as reported by the V4L2 driver. For multi-planar formats,\n this is the total size across all planes.\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @return Buffer length in bytes\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_length(&self, buffer: *const vsl_camera_buffer) -> u32 {
        (self
            .vsl_camera_buffer_length
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Returns the fourcc code of the camera buffer.\n\n Pixel format as negotiated with the driver during vsl_camera_init_device().\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @return FOURCC code\n @since 1.3\n @memberof VSLCamera"]
    pub unsafe fn vsl_camera_buffer_fourcc(&self, buffer: *const vsl_camera_buffer) -> u32 {
        (self
            .vsl_camera_buffer_fourcc
            .as_ref()
            .expect("Expected function, got error."))(buffer)
    }
    #[doc = " Reads the timestamp of the camera buffer.\n\n Retrieves the capture timestamp from the V4L2 buffer. Time is relative to\n CLOCK_MONOTONIC when the frame was captured by the camera driver.\n\n @param buffer Camera buffer from vsl_camera_get_data()\n @param seconds Output pointer for timestamp seconds\n @param nanoseconds Output pointer for sub-second nanoseconds\n @since 1.3"]
    pub unsafe fn vsl_camera_buffer_timestamp(
        &self,
        buffer: *const vsl_camera_buffer,
        seconds: *mut i64,
        nanoseconds: *mut i64,
    ) {
        (self
            .vsl_camera_buffer_timestamp
            .as_ref()
            .expect("Expected function, got error."))(buffer, seconds, nanoseconds)
    }
    #[doc = " Lists the supported single-planar formats of the camera.\n\n Queries V4L2 device for available single-planar pixel formats. Call before\n vsl_camera_init_device() to determine what formats to request.\n\n @param ctx Camera context from vsl_camera_open_device()\n @param codes Array to receive fourcc codes\n @param size Size of codes array\n @return Number of formats written to codes array, or -1 on error\n @since 1.3"]
    pub unsafe fn vsl_camera_enum_fmts(
        &self,
        ctx: *const vsl_camera,
        codes: *mut u32,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_enum_fmts
            .as_ref()
            .expect("Expected function, got error."))(ctx, codes, size)
    }
    #[doc = " Lists the supported multi-planar formats of the camera.\n\n Queries V4L2 device for available multi-planar pixel formats (e.g., NV12,\n NV21 with separate Y and UV planes). Call before vsl_camera_init_device().\n\n @param ctx Camera context from vsl_camera_open_device()\n @param codes Array to receive fourcc codes\n @param size Size of codes array\n @return Number of formats written to codes array, or -1 on error\n @since 1.3"]
    pub unsafe fn vsl_camera_enum_mplane_fmts(
        &self,
        ctx: *const vsl_camera,
        codes: *mut u32,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .vsl_camera_enum_mplane_fmts
            .as_ref()
            .expect("Expected function, got error."))(ctx, codes, size)
    }
    #[doc = " @brief Creates VSLDecoder instance\n\n Creates a hardware video decoder for H.264/H.265 using the best available\n backend (V4L2 preferred, Hantro fallback). The decoder is initialized on the\n first call to vsl_decode_frame().\n\n @param codec Codec type: VSL_DEC_H264 or VSL_DEC_HEVC\n @param fps Expected frame rate (used for buffer management)\n @return Pointer to VSLDecoder instance, or NULL on failure\n @since 1.4"]
    pub unsafe fn vsl_decoder_create(
        &self,
        codec: VSLDecoderCodec,
        fps: ::std::os::raw::c_int,
    ) -> *mut VSLDecoder {
        (self
            .vsl_decoder_create
            .as_ref()
            .expect("Expected function, got error."))(codec, fps)
    }
    #[doc = " @brief Creates VSLDecoder instance with explicit backend selection\n\n Creates a hardware video decoder with explicit backend selection. Use this\n when you need to force a specific backend instead of auto-detection.\n\n @param codec Codec fourcc: VSL_FOURCC('H','2','6','4') or\n              VSL_FOURCC('H','E','V','C')\n @param fps Expected frame rate (used for buffer management)\n @param backend Backend to use (AUTO, HANTRO, or V4L2)\n @return Pointer to VSLDecoder instance, or NULL on failure\n @since 2.0"]
    pub unsafe fn vsl_decoder_create_ex(
        &self,
        codec: u32,
        fps: ::std::os::raw::c_int,
        backend: VSLCodecBackend,
    ) -> *mut VSLDecoder {
        (self
            .vsl_decoder_create_ex
            .as_ref()
            .expect("Expected function, got error."))(codec, fps, backend)
    }
    #[doc = " @brief Decode compressed video frame\n\n Decodes H.264/H.265 data into a raw frame using hardware acceleration.\n First call initializes the decoder. May require multiple calls to decode\n one frame (returns VSL_DEC_INIT_INFO or VSL_DEC_FRAME_DEC).\n\n @param decoder VSLDecoder instance from vsl_decoder_create()\n @param data Pointer to compressed video data\n @param data_length Length of compressed data in bytes\n @param bytes_used Output: number of bytes consumed from data\n @param output_frame Output: decoded frame (NULL if frame not yet complete)\n @return VSL_DEC_SUCCESS (frame decoded), VSL_DEC_INIT_INFO (need more calls),\n         VSL_DEC_FRAME_DEC (frame in progress), or VSL_DEC_ERR (error)\n @since 1.4"]
    pub unsafe fn vsl_decode_frame(
        &self,
        decoder: *mut VSLDecoder,
        data: *const ::std::os::raw::c_void,
        data_length: ::std::os::raw::c_uint,
        bytes_used: *mut usize,
        output_frame: *mut *mut VSLFrame,
    ) -> VSLDecoderRetCode {
        (self
            .vsl_decode_frame
            .as_ref()
            .expect("Expected function, got error."))(
            decoder,
            data,
            data_length,
            bytes_used,
            output_frame,
        )
    }
    #[doc = " @brief Returns the decoded frame width\n\n Returns the width of decoded frames as determined from the stream headers.\n Only valid after decoder initialization (after first vsl_decode_frame()).\n\n @param decoder VSLDecoder instance\n @return Frame width in pixels\n @since 1.4"]
    pub unsafe fn vsl_decoder_width(&self, decoder: *const VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_width
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    #[doc = " @brief Returns the decoded frame height\n\n Returns the height of decoded frames as determined from the stream headers.\n Only valid after decoder initialization (after first vsl_decode_frame()).\n\n @param decoder VSLDecoder instance\n @return Frame height in pixels\n @since 1.4"]
    pub unsafe fn vsl_decoder_height(&self, decoder: *const VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_height
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    #[doc = " @brief Returns the decoder crop rectangle\n\n Returns the active video area within decoded frames, as specified in stream\n headers. Some encoded streams have padding that should be cropped.\n\n @param decoder VSLDecoder instance\n @return VSLRect with crop region (x, y, width, height)\n @since 1.4"]
    pub unsafe fn vsl_decoder_crop(&self, decoder: *const VSLDecoder) -> VSLRect {
        (self
            .vsl_decoder_crop
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }
    #[doc = " @brief Destroys VSLDecoder instance\n\n Frees all resources associated with the decoder, including hardware\n resources. Do not use the decoder after calling this function.\n\n @param decoder VSLDecoder instance to destroy\n @return 0 on success, -1 on error\n @since 1.4"]
    pub unsafe fn vsl_decoder_release(&self, decoder: *mut VSLDecoder) -> ::std::os::raw::c_int {
        (self
            .vsl_decoder_release
            .as_ref()
            .expect("Expected function, got error."))(decoder)
    }

    // ============== Helper Methods ==============

    /// Check if encoder functions are available in the loaded library.
    pub fn is_encoder_available(&self) -> bool {
        self.vsl_encoder_create.is_ok()
            && self.vsl_encoder_release.is_ok()
            && self.vsl_encode_frame.is_ok()
            && self.vsl_encoder_new_output_frame.is_ok()
    }

    /// Check if decoder functions are available in the loaded library.
    pub fn is_decoder_available(&self) -> bool {
        self.vsl_decoder_create.is_ok() && self.vsl_decoder_release.is_ok()
    }

    /// Check if vsl_decoder_create_ex is available (requires VideoStream 2.0+).
    pub fn is_decoder_create_ex_available(&self) -> bool {
        self.vsl_decoder_create_ex.is_ok()
    }

    /// Check if vsl_encoder_create_ex is available (requires VideoStream 2.0+).
    pub fn is_encoder_create_ex_available(&self) -> bool {
        self.vsl_encoder_create_ex.is_ok()
    }

    /// Check if backend selection is available for decoders.
    pub fn is_backend_selection_available(&self) -> bool {
        self.vsl_decoder_create_ex.is_ok()
    }

    /// Try to create an encoder, returning None if the symbol is not available.
    pub unsafe fn try_vsl_encoder_create(
        &self,
        profile: VSLEncoderProfile,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
    ) -> Option<*mut VSLEncoder> {
        self.vsl_encoder_create
            .as_ref()
            .ok()
            .map(|f| f(profile, outputFourcc, fps))
    }

    /// Try to create an encoder with backend selection, returning None if unavailable.
    pub unsafe fn try_vsl_encoder_create_ex(
        &self,
        profile: VSLEncoderProfile,
        outputFourcc: u32,
        fps: ::std::os::raw::c_int,
        backend: VSLCodecBackend,
    ) -> Option<*mut VSLEncoder> {
        self.vsl_encoder_create_ex
            .as_ref()
            .ok()
            .map(|f| f(profile, outputFourcc, fps, backend))
    }

    /// Try to release an encoder, returning false if the symbol is not available.
    pub unsafe fn try_vsl_encoder_release(&self, encoder: *mut VSLEncoder) -> bool {
        if let Ok(f) = self.vsl_encoder_release.as_ref() {
            f(encoder);
            true
        } else {
            false
        }
    }

    /// Try to encode a frame, returning None if the symbol is not available.
    pub unsafe fn try_vsl_encode_frame(
        &self,
        encoder: *mut VSLEncoder,
        source: *mut VSLFrame,
        destination: *mut VSLFrame,
        cropRegion: *const VSLRect,
        keyframe: *mut ::std::os::raw::c_int,
    ) -> Option<::std::os::raw::c_int> {
        self.vsl_encode_frame
            .as_ref()
            .ok()
            .map(|f| f(encoder, source, destination, cropRegion, keyframe))
    }

    /// Try to create an encoder output frame, returning None if unavailable.
    pub unsafe fn try_vsl_encoder_new_output_frame(
        &self,
        encoder: *const VSLEncoder,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        duration: i64,
        pts: i64,
        dts: i64,
    ) -> Option<*mut VSLFrame> {
        self.vsl_encoder_new_output_frame
            .as_ref()
            .ok()
            .map(|f| f(encoder, width, height, duration, pts, dts))
    }

    /// Try to create a decoder, returning None if the symbol is not available.
    pub unsafe fn try_vsl_decoder_create(
        &self,
        codec: VSLDecoderCodec,
        fps: ::std::os::raw::c_int,
    ) -> Option<*mut VSLDecoder> {
        self.vsl_decoder_create
            .as_ref()
            .ok()
            .map(|f| f(codec, fps))
    }

    /// Try to create a decoder with backend selection, returning None if unavailable.
    pub unsafe fn try_vsl_decoder_create_ex(
        &self,
        codec: u32,
        fps: ::std::os::raw::c_int,
        backend: VSLCodecBackend,
    ) -> Option<*mut VSLDecoder> {
        self.vsl_decoder_create_ex
            .as_ref()
            .ok()
            .map(|f| f(codec, fps, backend))
    }

    /// Try to get decoder width, returning None if unavailable.
    pub unsafe fn try_vsl_decoder_width(
        &self,
        decoder: *mut VSLDecoder,
    ) -> Option<::std::os::raw::c_int> {
        self.vsl_decoder_width.as_ref().ok().map(|f| f(decoder))
    }

    /// Try to get decoder height, returning None if unavailable.
    pub unsafe fn try_vsl_decoder_height(
        &self,
        decoder: *mut VSLDecoder,
    ) -> Option<::std::os::raw::c_int> {
        self.vsl_decoder_height.as_ref().ok().map(|f| f(decoder))
    }

    /// Try to get decoder crop region, returning None if unavailable.
    pub unsafe fn try_vsl_decoder_crop(&self, decoder: *mut VSLDecoder) -> Option<vsl_rect> {
        self.vsl_decoder_crop.as_ref().ok().map(|f| f(decoder))
    }

    /// Try to decode a frame, returning None if unavailable.
    pub unsafe fn try_vsl_decode_frame(
        &self,
        decoder: *mut VSLDecoder,
        data: *const ::std::os::raw::c_void,
        len: u32,
        bytes_used: *mut usize,
        output_frame: *mut *mut vsl_frame,
    ) -> Option<u32> {
        self.vsl_decode_frame
            .as_ref()
            .ok()
            .map(|f| f(decoder, data, len, bytes_used, output_frame))
    }

    /// Try to release a decoder, returning None if unavailable.
    pub unsafe fn try_vsl_decoder_release(&self, decoder: *mut VSLDecoder) -> Option<()> {
        self.vsl_decoder_release.as_ref().ok().map(|f| {
            f(decoder);
        })
    }
}
