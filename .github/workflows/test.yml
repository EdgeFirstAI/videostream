# GitHub Actions workflow for testing and code quality
#
# This workflow builds the Debug configuration with coverage enabled,
# runs unit tests (C, Python, and Rust), collects coverage data, and 
# performs static analysis including SonarCloud scanning.
#
# Action Versions (hash-pinned per SPS v2.1):
# - actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 (v4.2.2)
# - actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b (v5.3.0)
# - actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 (v4.4.3)
# - actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 (v4.1.8)
# - dtolnay/rust-toolchain@6d9817901c499d6b02debbb57edb38d33daa680b (stable)
# - Swatinem/rust-cache@f0deed1e0edfc6a9be95417288c0e1099b1eeec3 (v2.7.7)
# - taiki-e/install-action@1ee706eb04986370fc60419ba172594c51067f29 (v2.62.58)
# - SonarSource/sonarqube-scan-action@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602 (v6.0.0)
# - EnricoMi/publish-unit-test-result-action@170bf24d20d201b842d7a52403b73ed297e6645b (v2.18.0)
#
# Runner Notes:
# - ubuntu-22.04: Standard GitHub-hosted runner (x86_64)
# - ubuntu-22.04-arm: GitHub-hosted ARM64 runner for building aarch64 binaries
# - nxp-imx8mp-latest: NXP i.MX 8M Plus EVK - test-only runner (no toolchain)
#
# Build Strategy:
# - x86_64 and aarch64 builds happen on GitHub-hosted runners
# - imx8mp runner downloads aarch64 artifacts and runs tests only
# - This allows hardware-accelerated testing without requiring a full toolchain
#
# Coverage Strategy:
# - Each platform runs tests independently and generates coverage
# - Coverage artifacts are uploaded from all platforms
# - Dedicated sonarcloud job downloads and merges all coverage reports
#
# Testing Strategy (SPS v2.1):
# - Uses slipcover for Python coverage (faster than pytest-cov)
# - Uses cargo-nextest for Rust tests with JUnit XML output
# - Captures test performance metrics with /usr/bin/time -v
# - Publishes test results with EnricoMi/publish-unit-test-result-action

name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  # ===========================================================================
  # Build and Test on GitHub-hosted runners (x86_64 and aarch64)
  # ===========================================================================
  build-and-test:
    name: Build & Test (${{ matrix.platform.name }})
    runs-on: ${{ matrix.platform.runner }}
    permissions:
      contents: read
      checks: write
      pull-requests: write
    env:
      BUILD_WRAPPER_OUT_DIR: build/sonar
    strategy:
      matrix:
        platform:
          - name: x86_64
            runner: ubuntu-22.04
          - name: aarch64
            runner: ubuntu-22.04-arm
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0  # Full history for SonarCloud

      - name: Set up Python
        uses: actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b  # v5.3.0
        with:
          python-version: '3.10'

      - name: Create Python virtual environment
        run: |
          python3 -m venv venv
          echo "${{ github.workspace }}/venv/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get remove libunwind-* || true
          sudo apt-get install -y --no-install-recommends \
            build-essential cmake pkg-config \
            libgstreamer1.0-dev \
            libgstreamer-plugins-base1.0-dev \
            gstreamer1.0-tools \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-bad \
            python3-dev \
            libxml2-dev libxslt1-dev zlib1g-dev \
            lcov gcovr

      - name: Install Build Wrapper
        uses: SonarSource/sonarqube-scan-action/install-build-wrapper@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602  # v6.0.0

      - name: Detect build wrapper binary
        id: build-wrapper
        run: |
          # Detect architecture and set the correct build wrapper binary
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            echo "binary=build-wrapper-linux-x86-64" >> $GITHUB_OUTPUT
          elif [ "$ARCH" = "aarch64" ]; then
            echo "binary=build-wrapper-linux-aarch64" >> $GITHUB_OUTPUT
          else
            echo "Unsupported architecture: $ARCH"
            exit 1
          fi
          echo "Detected architecture: $ARCH"

      - name: Configure CMake
        run: |
          cmake -S . -B build \
                -DCMAKE_BUILD_TYPE=Debug \
                -DENABLE_COVER=ON \
                -DENABLE_VPU=OFF \
                -DENABLE_G2D=OFF \
                -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

      - name: Build with SonarCloud build wrapper
        run: |
          ${{ steps.build-wrapper.outputs.binary }} --out-dir ${{ env.BUILD_WRAPPER_OUT_DIR }} \
            cmake --build build -j$(nproc)

      - name: Install Python test dependencies
        run: |
          venv/bin/pip install --upgrade pip setuptools wheel
          venv/bin/pip install pytest slipcover pytest-timeout
          venv/bin/pip install -r requirements.txt

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@6d9817901c499d6b02debbb57edb38d33daa680b  # stable
        with:
          components: llvm-tools-preview, clippy, rustfmt

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@f0deed1e0edfc6a9be95417288c0e1099b1eeec3  # v2.7.7
        with:
          shared-key: rust-${{ matrix.platform.name }}
          cache-on-failure: true

      - name: Install cargo tools
        uses: taiki-e/install-action@1ee706eb04986370fc60419ba172594c51067f29  # v2.62.58
        with:
          tool: cargo-llvm-cov@0.6.16,cargo-nextest,cargo-export

      - name: Check Rust formatting
        run: cargo fmt --all -- --check

      - name: Run Clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings

      - name: Run Python tests with coverage
        run: |
          set -o pipefail
          export LD_LIBRARY_PATH=$(pwd)/build:$LD_LIBRARY_PATH
          export VIDEOSTREAM_LIBRARY=$(pwd)/build/libvideostream.so
          /usr/bin/time -v venv/bin/python -m slipcover --source deepview --xml --out build/coverage_python.xml \
            -m pytest tests -v --junitxml=build/pytest_results.xml \
            2>&1 | tee build/test-metrics-python-${{ matrix.platform.name }}.txt

      - name: Run Rust tests with coverage
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build:$LD_LIBRARY_PATH
        run: |
          set -o pipefail
          /usr/bin/time -v cargo llvm-cov nextest --workspace --all-features \
            --lcov --output-path build/coverage_rust.lcov 2>&1 | tee build/test-metrics-rust-${{ matrix.platform.name }}.txt

      - name: Export Rust test binaries for hardware testing (aarch64 only)
        if: matrix.platform.name == 'aarch64'
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build:$LD_LIBRARY_PATH
        run: |
          # Set up coverage environment for building instrumented test binaries
          source <(cargo llvm-cov show-env --export-prefix)
          
          # Build test binaries with coverage instrumentation (including ignored tests)
          # Using --run-ignored=all ensures camera tests are built
          cargo nextest run --workspace --all-features --no-run --run-ignored=all
          
          # Export test binaries to a directory for artifact upload
          mkdir -p target/tests
          cargo export target/tests -- test --workspace --all-features
          
          # Save coverage environment variables for use on target hardware
          cargo llvm-cov show-env > target/tests/llvm-cov-env.sh
          
          # Copy the LLVM tools needed to process profraw on the target (if available locally)
          # These are needed to generate reports from profraw files
          LLVM_PROFDATA=$(cargo llvm-cov show-env | grep LLVM_PROFDATA | cut -d'=' -f2 | tr -d '"')
          if [ -f "$LLVM_PROFDATA" ]; then
            cp "$LLVM_PROFDATA" target/tests/ || true
          fi
          
          echo "Exported test binaries:"
          ls -la target/tests/

      - name: Generate C/C++ coverage reports (after all tests that call into libvideostream.so)
        run: |
          # Generate SonarQube-compatible XML coverage report using gcovr
          # This captures coverage from Python tests, Rust tests, and any C tests
          # Note: gcovr --sonarqube produces the format expected by sonar.coverageReportPaths
          gcovr -r . --sonarqube -o build/coverage_c_sonar.xml build/
          
          # Also generate legacy gcov files (for debugging)
          mkdir -p build/gcov
          (cd build && find . -name "*.gcno" -exec gcov -p {} \; 2>/dev/null || true)
          (cd build && mv *.gcov gcov/ 2>/dev/null || true)
          
          echo "=== C coverage report generated ==="
          head -30 build/coverage_c_sonar.xml || echo "No coverage report generated"

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: coverage-${{ matrix.platform.name }}
          path: |
            build/gcov/
            build/coverage_c_sonar.xml
            build/coverage_python.xml
            build/coverage_rust.lcov
          retention-days: 30

      - name: Upload test results and metadata
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: test-results-${{ matrix.platform.name }}
          path: |
            build/pytest_results.xml
            build/coverage_c.xml
            target/nextest/default/test-results.xml
            build/test-metrics-*-${{ matrix.platform.name }}.txt
          retention-days: 30

      - name: Upload build wrapper output
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: build-wrapper-output-${{ matrix.platform.name }}
          path: ${{ env.BUILD_WRAPPER_OUT_DIR }}
          retention-days: 30

      - name: Upload build artifacts for hardware testing (aarch64 only)
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: matrix.platform.name == 'aarch64'
        with:
          name: build-aarch64
          path: |
            build/libvideostream.so*
            build/vsl-*
            build/CMakeFiles/**/*.gcno
          retention-days: 7

      - name: Upload Rust test binaries for hardware testing (aarch64 only)
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: matrix.platform.name == 'aarch64'
        with:
          name: rust-tests-aarch64
          path: |
            target/tests/
          retention-days: 7

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@170bf24d20d201b842d7a52403b73ed297e6645b  # v2.18.0
        if: always()
        with:
          files: |
            build/pytest_results.xml
            target/nextest/default/test-results.xml
          check_name: Test Results (${{ matrix.platform.name }})
          comment_mode: always
          # ignore_runs helps avoid double-counting when tests report multiple runs
          ignore_runs: true

  # ===========================================================================
  # Hardware Testing on NXP i.MX8M Plus (test-only, no build)
  # ===========================================================================
  hardware-test:
    name: Hardware Test (imx8mp)
    needs: build-and-test
    runs-on: nxp-imx8mp-latest
    permissions:
      contents: read
      checks: write
      pull-requests: write

    steps:
      - name: Clean workspace (self-hosted runner)
        run: |
          # Self-hosted runners persist state between runs
          rm -rf build/ venv/ coverage/ target/ rust-tests/ 2>/dev/null || true
          find . -name "*.gcda" -delete 2>/dev/null || true
          find . -name "*.profraw" -delete 2>/dev/null || true

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Download aarch64 build artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          name: build-aarch64
          path: build/

      - name: Download Rust test binaries
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          name: rust-tests-aarch64
          path: rust-tests/

      - name: Create Python virtual environment
        run: |
          python3 -m venv venv
          echo "${{ github.workspace }}/venv/bin" >> $GITHUB_PATH

      - name: Install Python test dependencies
        run: |
          venv/bin/pip install --upgrade pip setuptools wheel
          venv/bin/pip install pytest slipcover pytest-timeout
          venv/bin/pip install -r requirements.txt

      - name: Debug environment info
        run: |
          echo "=== User and groups ==="
          whoami
          id
          groups
          echo ""
          echo "=== DMA heap devices ==="
          ls -la /dev/dma_heap/ || echo "DMA heap directory not found"
          echo ""
          echo "=== Video devices ==="
          ls -la /dev/video* 2>/dev/null || echo "No video devices found"
          v4l2-ctl --list-devices 2>/dev/null || echo "v4l2-ctl not available"
          echo ""
          echo "=== Camera device /dev/video3 details ==="
          v4l2-ctl --device=/dev/video3 --all 2>&1 || echo "Could not query /dev/video3"
          echo ""
          echo "=== Camera formats on /dev/video3 ==="
          v4l2-ctl --device=/dev/video3 --list-formats-ext 2>&1 || echo "Could not list formats"
          echo ""
          echo "=== Downloaded Rust test binaries ==="
          ls -la rust-tests/
          echo ""
          echo "=== Downloaded build artifacts ==="
          ls -la build/

      - name: Run Python tests with coverage (hardware accelerated)
        env:
          # Redirect gcda files to workspace (processed by ubuntu-22.04-arm job)
          GCOV_PREFIX: ${{ github.workspace }}
          GCOV_PREFIX_STRIP: 5
        run: |
          set -o pipefail
          export LD_LIBRARY_PATH=$(pwd)/build:$LD_LIBRARY_PATH
          export VIDEOSTREAM_LIBRARY=$(pwd)/build/libvideostream.so
          /usr/bin/time -v venv/bin/python -m slipcover --source deepview --xml --out build/coverage_python.xml \
            -m pytest tests -v --junitxml=build/pytest_results.xml \
            2>&1 | tee build/test-metrics-python-imx8mp.txt

      - name: Run pre-built Rust tests with hardware access
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build:$LD_LIBRARY_PATH
          # Redirect gcda files to workspace (processed by ubuntu-22.04-arm job)
          GCOV_PREFIX: ${{ github.workspace }}
          GCOV_PREFIX_STRIP: 5
        run: |
          set -o pipefail
          mkdir -p build/rust-test-results
          
          # Set up profraw collection directory
          export LLVM_PROFILE_FILE="${{ github.workspace }}/build/profraw/imx8mp-%p-%m.profraw"
          mkdir -p build/profraw
          
          # Make test binaries executable
          chmod +x rust-tests/*
          
          # Track overall test status
          TEST_FAILED=0
          
          # Run each test binary and collect results
          echo "Running pre-built Rust test binaries..."
          for test_bin in rust-tests/*; do
            if [ -x "$test_bin" ] && [ -f "$test_bin" ]; then
              test_name=$(basename "$test_bin")
              echo "=== Running $test_name ==="
              # --include-ignored runs tests marked with #[ignore] (camera tests need real hardware)
              # --test-threads=1 for deterministic execution on hardware
              if ! /usr/bin/time -v "$test_bin" --include-ignored --test-threads=1 2>&1 | tee "build/rust-test-results/${test_name}.txt"; then
                echo "FAILED: $test_name"
                TEST_FAILED=1
              fi
            fi
          done
          
          echo ""
          echo "=== Profraw files generated ==="
          ls -la build/profraw/ || echo "No profraw files generated"
          
          # Fail the step if any test failed
          if [ $TEST_FAILED -ne 0 ]; then
            echo ""
            echo "ERROR: One or more Rust tests failed!"
            exit 1
          fi

      - name: Collect gcda files for processing
        if: always()
        run: |
          # Find all gcda files generated during testing
          echo "=== GCDA files generated ==="
          find build/ -name "*.gcda" -type f 2>/dev/null | head -20 || echo "No gcda files found"
          
          # Create directory structure for gcov processing
          mkdir -p build/gcda-imx8mp
          
          # Copy gcda files preserving directory structure
          if find build/ -name "*.gcda" -type f | head -1 | grep -q .; then
            echo "Copying gcda files..."
            find build/ -name "*.gcda" -type f -exec cp --parents {} build/gcda-imx8mp/ \;
            echo "Copied $(find build/gcda-imx8mp -name '*.gcda' | wc -l) gcda files"
          fi

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: coverage-imx8mp
          path: |
            build/coverage_python.xml
            build/profraw/
            build/gcda-imx8mp/
          retention-days: 30

      - name: Upload test results and metadata
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: test-results-imx8mp
          path: |
            build/pytest_results.xml
            build/test-metrics-*-imx8mp.txt
            build/rust-test-results/
          retention-days: 30

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@170bf24d20d201b842d7a52403b73ed297e6645b  # v2.18.0
        if: always()
        with:
          files: |
            build/pytest_results.xml
          check_name: Test Results (imx8mp)
          comment_mode: always
          # ignore_runs helps avoid double-counting when tests report multiple runs
          ignore_runs: true

  # ===========================================================================
  # Process Hardware Coverage (gcda -> gcov on ubuntu-22.04-arm)
  # ===========================================================================
  process-hardware-coverage:
    name: Process Hardware Coverage
    needs: [build-and-test, hardware-test]
    runs-on: ubuntu-22.04-arm
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Download aarch64 build artifacts (contains gcno files)
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          name: build-aarch64
          path: build/

      - name: Download Rust test binaries (contains llvm-cov env)
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          name: rust-tests-aarch64
          path: rust-tests/

      - name: Download imx8mp coverage artifacts (contains gcda and profraw files)
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          name: coverage-imx8mp
          path: coverage-imx8mp/

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@6d9817901c499d6b02debbb57edb38d33daa680b  # stable
        with:
          toolchain: stable

      - name: Install coverage tools
        uses: taiki-e/install-action@1ee706eb04986370fc60419ba172594c51067f29  # v2.62.58
        with:
          tool: cargo-llvm-cov

      - name: Install gcov tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gcovr

      - name: Process Rust profraw files into coverage report
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build:$LD_LIBRARY_PATH
        run: |
          echo "=== Profraw files from imx8mp ==="
          find coverage-imx8mp/ -name "*.profraw" -type f || echo "No profraw files found"
          
          # Copy profraw files to where cargo-llvm-cov expects them
          mkdir -p target/llvm-cov-target
          find coverage-imx8mp/ -name "*.profraw" -type f -exec cp {} target/llvm-cov-target/ \;
          
          PROFRAW_COUNT=$(find target/llvm-cov-target/ -name "*.profraw" | wc -l)
          echo "Found $PROFRAW_COUNT profraw files"
          
          if [ "$PROFRAW_COUNT" -gt 0 ]; then
            echo ""
            echo "=== Generating Rust coverage report ==="
            # Generate coverage from the profraw files
            # Note: This requires the same source code that was used to build the tests
            cargo llvm-cov report \
              --ignore-filename-regex='/.cargo/registry|/rustc/' \
              --lcov --output-path build/coverage_rust_imx8mp.lcov \
              || echo "WARNING: Could not generate Rust coverage report"
            
            if [ -f build/coverage_rust_imx8mp.lcov ]; then
              echo "Generated build/coverage_rust_imx8mp.lcov"
              head -20 build/coverage_rust_imx8mp.lcov
            fi
          else
            echo "No profraw files to process"
          fi

      - name: Process gcda files into SonarQube coverage format
        run: |
          echo "=== Build artifacts (gcno files) ==="
          find build/ -name "*.gcno" -type f | head -20 || echo "No gcno files found"
          
          echo ""
          echo "=== Coverage artifacts from imx8mp ==="
          find coverage-imx8mp/ -name "*.gcda" -type f | head -20 || echo "No gcda files found"
          
          # Move gcda files to match gcno file locations
          if find coverage-imx8mp/ -name "*.gcda" -type f | head -1 | grep -q .; then
            echo ""
            echo "=== Relocating gcda files to match gcno locations ==="
            # The gcda files need to be in the same directory as their corresponding gcno files
            find coverage-imx8mp/ -name "*.gcda" -type f | while read gcda; do
              # Extract the relative path from the gcda file
              gcda_name=$(basename "$gcda")
              # Find matching gcno file
              gcno_path=$(find build/ -name "${gcda_name%.gcda}.gcno" -type f | head -1)
              if [ -n "$gcno_path" ]; then
                gcno_dir=$(dirname "$gcno_path")
                echo "Copying $gcda_name to $gcno_dir/"
                cp "$gcda" "$gcno_dir/"
              else
                echo "WARNING: No matching gcno for $gcda_name"
              fi
            done
          fi
          
          # Generate SonarQube-compatible XML coverage report
          echo ""
          echo "=== Generating SonarQube coverage report ==="
          gcovr -r . --sonarqube -o build/coverage_c_imx8mp_sonar.xml build/ || echo "gcovr failed"
          
          if [ -f build/coverage_c_imx8mp_sonar.xml ]; then
            echo "Generated build/coverage_c_imx8mp_sonar.xml"
            head -30 build/coverage_c_imx8mp_sonar.xml
          else
            echo "WARNING: No C coverage report generated"
          fi

      - name: Upload processed coverage
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        with:
          name: coverage-imx8mp-processed
          path: |
            build/coverage_c_imx8mp_sonar.xml
            build/coverage_rust_imx8mp.lcov
            coverage-imx8mp/build/coverage_python.xml
          retention-days: 30

  # ===========================================================================
  # SonarCloud Analysis (aggregates coverage from all platforms)
  # ===========================================================================
  sonarcloud:
    name: SonarCloud Analysis
    needs: [build-and-test, hardware-test, process-hardware-coverage]
    runs-on: ubuntu-22.04
    if: github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0  # Full history for SonarCloud blame data

      - name: Download all coverage artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          pattern: coverage-*
          path: coverage/

      - name: Download all build wrapper outputs
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          pattern: build-wrapper-output-*
          path: build-wrapper/

      - name: Organize coverage files for SonarCloud
        run: |
          # List all downloaded artifacts for debugging
          echo "=== Downloaded coverage artifacts ==="
          find coverage/ -type f
          echo ""
          echo "=== Downloaded build wrapper outputs ==="
          find build-wrapper/ -type f | head -20
          
          # Create consolidated directory structure
          mkdir -p build/sonar
          
          # Use x86_64 build wrapper output (all platforms produce similar data)
          # Build wrapper generates compile_commands.json in its output directory
          if [ -d "build-wrapper/build-wrapper-output-x86_64" ]; then
            cp -r build-wrapper/build-wrapper-output-x86_64/* build/sonar/
          fi
          
          # Verify compile_commands.json was generated
          if [ -f "build/sonar/compile_commands.json" ]; then
            echo "Found compile_commands.json from build wrapper"
          else
            echo "WARNING: compile_commands.json not found in build wrapper output"
          fi
          
          # Fix source paths in coverage XML files
          # Coverage files contain absolute source paths from different CI runners
          # We need to normalize them to the current workspace path
          echo ""
          echo "=== Normalizing coverage file source paths ==="
          WORKSPACE="${{ github.workspace }}"
          for xml_file in $(find coverage/ -name "*.xml" -type f); do
            echo "Processing: $xml_file"
            # Replace any absolute source path with the current workspace
            # Common patterns: /home/runner/work/videostream/videostream, /github/workspace, etc.
            sed -i "s|<source>[^<]*</source>|<source>$WORKSPACE</source>|g" "$xml_file"
          done
          
          # Collect all coverage reports
          # Python coverage (Cobertura XML format)
          PYTHON_REPORTS=$(find coverage/ -name "coverage_python.xml" | tr '\n' ',' | sed 's/,$//')
          
          # Rust coverage (LCOV format)
          RUST_REPORTS=$(find coverage/ -name "coverage_rust*.lcov" | tr '\n' ',' | sed 's/,$//')
          
          # C/C++ coverage (SonarQube XML format from gcovr --sonarqube)
          C_REPORTS=$(find coverage/ -name "coverage_c*_sonar.xml" | tr '\n' ',' | sed 's/,$//')
          
          echo ""
          echo "=== Coverage report paths ==="
          echo "Python coverage reports: $PYTHON_REPORTS"
          echo "Rust coverage reports: $RUST_REPORTS"
          echo "C/C++ coverage reports: $C_REPORTS"
          
          # Show sample of coverage report to verify source path normalization
          SAMPLE_REPORT=$(find coverage/ -name "*.xml" | head -1)
          if [ -n "$SAMPLE_REPORT" ] && [ -f "$SAMPLE_REPORT" ]; then
            echo ""
            echo "=== Sample coverage report (first 15 lines) ==="
            head -15 "$SAMPLE_REPORT"
          fi
          
          # Export for next step
          echo "PYTHON_COVERAGE_PATHS=$PYTHON_REPORTS" >> $GITHUB_ENV
          echo "RUST_COVERAGE_PATHS=$RUST_REPORTS" >> $GITHUB_ENV
          echo "C_COVERAGE_PATHS=$C_REPORTS" >> $GITHUB_ENV

      - name: Run SonarCloud scan
        uses: SonarSource/sonarqube-scan-action@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602  # v6.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.python.coverage.reportPaths=${{ env.PYTHON_COVERAGE_PATHS }}
            -Dsonar.rust.lcov.reportPaths=${{ env.RUST_COVERAGE_PATHS }}
            -Dsonar.coverageReportPaths=${{ env.C_COVERAGE_PATHS }}
            -Dsonar.cfamily.compile-commands=build/sonar/compile_commands.json
