# GitHub Actions workflow for testing and code quality
#
# This workflow builds the Debug configuration with coverage enabled,
# runs unit tests (C, Python, and Rust), collects coverage data, and 
# performs static analysis including SonarCloud scanning.
#
# Action Versions (hash-pinned per SPS v2.1):
# - actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 (v4.2.2)
# - actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b (v5.3.0)
# - actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 (v4.4.3)
# - actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 (v4.1.8)
# - dtolnay/rust-toolchain@7b1c307e0dcbda6122208f10795a713336a9b35a (stable)
# - Swatinem/rust-cache@82a92a5b8b938b84d92384cb7f96219435c6f0e0 (v2.7.7)
# - SonarSource/sonarqube-scan-action@e44258b109568baa0df60ed515909fc6c72cba92 (v6)
# - EnricoMi/publish-unit-test-result-action@567cc7f8dcea3f8d4a602e63889c4a4f5e6d7e62 (v2.18.0)
#
# Runner Notes:
# - ubuntu-22.04: Standard GitHub-hosted runner (x86_64)
# - ubuntu-22.04-arm: Custom larger runner (ARM64) configured in organization settings
# - nxp-imx8mp-latest: NXP i.MX 8M Plus EVK with hardware accelerators (BSP 6.12.34-2.1.0)
#
# Coverage Strategy:
# - Each platform runs tests independently and generates coverage
# - Coverage artifacts are uploaded from all platforms
# - Dedicated sonarcloud job downloads and merges all coverage reports
# - This scales to support additional embedded device runners
#
# Testing Strategy (SPS v2.1):
# - Uses slipcover for Python coverage (faster than pytest-cov)
# - Uses cargo-nextest for Rust tests with JUnit XML output
# - Captures test performance metrics with /usr/bin/time -v
# - Publishes test results with EnricoMi/publish-unit-test-result-action

name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: Test and Coverage (${{ matrix.platform.name }})
    runs-on: ${{ matrix.platform.runner }}
    permissions:
      contents: read
      checks: write
      pull-requests: write
    env:
      BUILD_WRAPPER_OUT_DIR: build/sonar
    strategy:
      matrix:
        platform:
          - name: x86_64
            runner: ubuntu-22.04
            enable_hardware: false
          - name: aarch64
            runner: ubuntu-22.04-arm
            enable_hardware: false
          - name: imx8mp
            runner: nxp-imx8mp-latest
            enable_hardware: true
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0  # Full history for SonarCloud

      - name: Set up Python
        uses: actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b  # v5.3.0
        with:
          python-version: '3.8'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get remove libunwind-*
          sudo apt-get install -y --no-install-recommends \
            build-essential cmake pkg-config \
            libgstreamer1.0-dev \
            libgstreamer-plugins-base1.0-dev \
            gstreamer1.0-tools \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-bad \
            python3 python3-pip python3-dev \
            libxml2-dev libxslt1-dev zlib1g-dev \
            lcov gcovr

      - name: Install Build Wrapper
        uses: SonarSource/sonarqube-scan-action/install-build-wrapper@e44258b109568baa0df60ed515909fc6c72cba92  # v6

      - name: Detect build wrapper binary
        id: build-wrapper
        run: |
          # Detect architecture and set the correct build wrapper binary
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            echo "binary=build-wrapper-linux-x86-64" >> $GITHUB_OUTPUT
          elif [ "$ARCH" = "aarch64" ]; then
            echo "binary=build-wrapper-linux-aarch64" >> $GITHUB_OUTPUT
          else
            echo "Unsupported architecture: $ARCH"
            exit 1
          fi
          echo "Detected architecture: $ARCH"

      - name: Configure CMake
        run: |
          cmake -S . -B build \
                -DCMAKE_BUILD_TYPE=Debug \
                -DENABLE_COVER=ON \
                -DENABLE_VPU=${{ matrix.platform.enable_hardware && 'ON' || 'OFF' }} \
                -DENABLE_G2D=${{ matrix.platform.enable_hardware && 'ON' || 'OFF' }} \
                -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

      - name: Build with SonarCloud build wrapper
        run: |
          ${{ steps.build-wrapper.outputs.binary }} --out-dir ${{ env.BUILD_WRAPPER_OUT_DIR }} \
            cmake --build build -j$(nproc)

      - name: Install Python test dependencies
        run: |
          python3 -m pip install --upgrade pip setuptools wheel
          python3 -m pip install pytest slipcover pytest-timeout
          python3 -m pip install -r requirements.txt

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@7b1c307e0dcbda6122208f10795a713336a9b35a  # stable
        with:
          components: llvm-tools-preview, clippy, rustfmt

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@82a92a5b8b938b84d92384cb7f96219435c6f0e0  # v2.7.7
        with:
          shared-key: rust-${{ matrix.platform.name }}
          cache-on-failure: true

      - name: Install cargo tools
        run: |
          cargo install cargo-llvm-cov --version 0.6.16
          cargo install cargo-nextest --locked

      - name: Check Rust formatting
        run: cargo fmt --all -- --check

      - name: Run Clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings

      - name: Run Python tests with coverage
        run: |
          export LD_LIBRARY_PATH=$(pwd)/build:$LD_LIBRARY_PATH
          export VIDEOSTREAM_LIBRARY=$(pwd)/build/libvideostream.so
          /usr/bin/time -v python3 -m slipcover -m pytest tests -v \
            --junitxml=build/pytest_results.xml 2>&1 | tee build/test-metrics-python-${{ matrix.platform.name }}.txt

          # slipcover generates .coverage file, convert to XML for SonarCloud
          python3 -m coverage xml -o build/coverage_python.xml

      - name: Run Rust tests with coverage
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build:$LD_LIBRARY_PATH
        run: |
          /usr/bin/time -v cargo llvm-cov nextest --workspace --all-features \
            --cobertura --output-path build/coverage_rust.xml 2>&1 | tee build/test-metrics-rust-${{ matrix.platform.name }}.txt

      - name: Generate C/C++ coverage reports (after all tests that call into libvideostream.so)
        run: |
          # Generate native .gcov files in build/gcov directory
          # This captures coverage from Python tests, Rust tests, and any C tests
          mkdir -p build/gcov
          (cd build && find . -name "*.gcno" -exec gcov -p {} \; 2>/dev/null || true)
          (cd build && mv *.gcov gcov/ 2>/dev/null || true)
          # Also generate Cobertura XML for artifacts/alternative analysis
          gcovr -r . --cobertura -o build/coverage_c.xml build/

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: coverage-${{ matrix.platform.name }}
          path: |
            build/gcov/
            build/coverage_python.xml
            build/coverage_rust.xml
          retention-days: 30

      - name: Upload test results and metadata
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: test-results-${{ matrix.platform.name }}
          path: |
            build/pytest_results.xml
            build/coverage_c.xml
            target/nextest/default/test-results.xml
            build/test-metrics-*-${{ matrix.platform.name }}.txt
          retention-days: 30

      - name: Upload build wrapper output
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882  # v4.4.3
        if: always()
        with:
          name: build-wrapper-output-${{ matrix.platform.name }}
          path: ${{ env.BUILD_WRAPPER_OUT_DIR }}
          retention-days: 30

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@567cc7f8dcea3f8d4a602e63889c4a4f5e6d7e62  # v2.18.0
        if: always()
        with:
          files: |
            build/pytest_results.xml
            target/nextest/default/test-results.xml
          check_name: Test Results (${{ matrix.platform.name }})
          comment_mode: always

  sonarcloud:
    name: SonarCloud Analysis
    needs: test
    runs-on: ubuntu-22.04
    if: github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0  # Full history for SonarCloud blame data

      - name: Download all coverage artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          pattern: coverage-*
          path: coverage/

      - name: Download all build wrapper outputs
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16  # v4.1.8
        with:
          pattern: build-wrapper-output-*
          path: build-wrapper/

      - name: Organize coverage files for SonarCloud
        run: |
          # List all downloaded artifacts for debugging
          echo "Downloaded coverage artifacts:"
          find coverage/ -type f
          echo "Downloaded build wrapper outputs:"
          find build-wrapper/ -type f | head -20
          
          # Create consolidated directory structure
          mkdir -p merged-coverage/gcov
          mkdir -p build/sonar
          
          # Merge all gcov files from all platforms
          find coverage/ -name "*.gcov" -exec cp {} merged-coverage/gcov/ \;
          
          # Use x86_64 build wrapper output (all platforms produce similar data)
          # Build wrapper generates compile_commands.json in its output directory
          if [ -d "build-wrapper/build-wrapper-output-x86_64" ]; then
            cp -r build-wrapper/build-wrapper-output-x86_64/* build/sonar/
          fi
          
          # Verify compile_commands.json was generated
          if [ -f "build/sonar/compile_commands.json" ]; then
            echo "Found compile_commands.json from build wrapper"
          else
            echo "WARNING: compile_commands.json not found in build wrapper output"
          fi
          
          # Create comma-separated lists for coverage report paths
          PYTHON_REPORTS=$(find coverage/ -name "coverage_python.xml" | tr '\n' ',' | sed 's/,$//')
          RUST_REPORTS=$(find coverage/ -name "coverage_rust.xml" | tr '\n' ',' | sed 's/,$//')
          
          echo "Python coverage reports: $PYTHON_REPORTS"
          echo "Rust coverage reports: $RUST_REPORTS"
          echo "C/C++ gcov files: $(find merged-coverage/gcov/ -name '*.gcov' | wc -l) files"
          
          # Export for next step
          echo "PYTHON_COVERAGE_PATHS=$PYTHON_REPORTS" >> $GITHUB_ENV
          echo "RUST_COVERAGE_PATHS=$RUST_REPORTS" >> $GITHUB_ENV

      - name: Run SonarCloud scan
        uses: SonarSource/sonarqube-scan-action@e44258b109568baa0df60ed515909fc6c72cba92  # v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.python.coverage.reportPaths=${{ env.PYTHON_COVERAGE_PATHS }}
            -Dsonar.rust.cobertura.reportPaths=${{ env.RUST_COVERAGE_PATHS }}
            -Dsonar.cfamily.gcov.reportsPath=merged-coverage/gcov
            -Dsonar.cfamily.compile-commands=build/sonar/compile_commands.json
